diff --git a/modern_theme/LICENSE b/modern_theme/LICENSE
new file mode 100644
index 0000000..d1e1072
--- /dev/null
+++ b/modern_theme/LICENSE
@@ -0,0 +1 @@
+MIT License
diff --git a/modern_theme/README.md b/modern_theme/README.md
new file mode 100644
index 0000000..8db39c2
--- /dev/null
+++ b/modern_theme/README.md
@@ -0,0 +1 @@
+# Modern Theme for ERPNext
diff --git a/modern_theme/modern_theme/__init__.py b/modern_theme/modern_theme/__init__.py
new file mode 100644
index 0000000..9d0dcab
--- /dev/null
+++ b/modern_theme/modern_theme/__init__.py
@@ -0,0 +1,2 @@
+from __future__ import unicode_literals
+__version__ = "0.0.1"
diff --git a/modern_theme/modern_theme/config/desktop.py b/modern_theme/modern_theme/config/desktop.py
new file mode 100644
index 0000000..1b09357
--- /dev/null
+++ b/modern_theme/modern_theme/config/desktop.py
@@ -0,0 +1,6 @@
+# -*- coding: utf-8 -*-
+from __future__ import unicode_literals
+from frappe import _
+
+def get_data():
+	return [{"module_name": "Modern Theme", "color": "grey", "icon": "octicon octicon-paintcan", "type": "module", "label": _("Modern Theme")}]
diff --git a/modern_theme/modern_theme/hooks.py b/modern_theme/modern_theme/hooks.py
new file mode 100644
index 0000000..04dfb37
--- /dev/null
+++ b/modern_theme/modern_theme/hooks.py
@@ -0,0 +1,11 @@
+from . import __version__ as app_version
+
+app_name = "modern_theme"
+app_title = "Modern Theme"
+app_publisher = "Modern Theme"
+app_description = "A modern theme inspired by ClickUp for ERPNext"
+app_icon = "octicon octicon-paintcan"
+app_color = "grey"
+app_email = "dev@example.com"
+app_license = "MIT"
+app_include_css = "/assets/modern_theme/css/modern_theme.css"
diff --git a/modern_theme/modern_theme/modules.txt b/modern_theme/modern_theme/modules.txt
new file mode 100644
index 0000000..48c38a3
--- /dev/null
+++ b/modern_theme/modern_theme/modules.txt
@@ -0,0 +1 @@
+Modern Theme
diff --git a/modern_theme/modern_theme/public/css/modern_theme.css b/modern_theme/modern_theme/public/css/modern_theme.css
new file mode 100644
index 0000000..1c5a66c
--- /dev/null
+++ b/modern_theme/modern_theme/public/css/modern_theme.css
@@ -0,0 +1,13 @@
+:root {
+  --clickup-purple: #7b68ee; --primary: var(--clickup-purple);
+  --text-color: #333; --border-color: #dee2e6;
+  --font-family-sans-serif: "Inter", -apple-system, sans-serif;
+}
+body {
+  font-family: var(--font-family-sans-serif);
+  color: var(--text-color);
+  background-color: #f8f9fa;
+}
+.navbar-default { background-color: #fff !important; border-bottom: 1px solid var(--border-color); }
+.page-sidebar { background-color: #fff; border-right: 1px solid var(--border-color); }
+.btn-primary { background-color: var(--primary); border-color: var(--primary); }
diff --git a/modern_theme/pyproject.toml b/modern_theme/pyproject.toml
new file mode 100644
index 0000000..177d16e
--- /dev/null
+++ b/modern_theme/pyproject.toml
@@ -0,0 +1,13 @@
+[project]
+name = "modern_theme"
+authors = [
+    { name = "Modern Theme", email = "dev@example.com" }
+]
+description = "A modern theme for Frappe."
+requires-python = ">=3.10"
+readme = "README.md"
+version = "0.0.1"
+dependencies = []
+[build-system]
+requires = ["setuptools"]
+build-backend = "setuptools.build_meta"
diff --git a/setup.py b/setup.py
index e0528c9..90f48f4 100644
--- a/setup.py
+++ b/setup.py
@@ -1,3 +1,4 @@
+# setup.py
 from setuptools import setup, find_packages
 
 setup(
@@ -6,4 +7,4 @@ setup(
     packages=find_packages(),
     include_package_data=True,
     install_requires=["frappe"],
-) 
\ No newline at end of file
+)
diff --git a/tmp_repo_contents/.env.example b/tmp_repo_contents/.env.example
deleted file mode 100644
index 2c5babf..0000000
--- a/tmp_repo_contents/.env.example
+++ /dev/null
@@ -1,10 +0,0 @@
-# API Keys (Required to enable respective provider)
-ANTHROPIC_API_KEY="your_anthropic_api_key_here"       # Required: Format: sk-ant-api03-...
-PERPLEXITY_API_KEY="your_perplexity_api_key_here"     # Optional: Format: pplx-...
-OPENAI_API_KEY="your_openai_api_key_here"             # Optional, for OpenAI/OpenRouter models. Format: sk-proj-...
-GOOGLE_API_KEY="your_google_api_key_here"             # Optional, for Google Gemini models.
-MISTRAL_API_KEY="your_mistral_key_here"               # Optional, for Mistral AI models.
-XAI_API_KEY="YOUR_XAI_KEY_HERE"                       # Optional, for xAI AI models.
-AZURE_OPENAI_API_KEY="your_azure_key_here"            # Optional, for Azure OpenAI models (requires endpoint in .taskmaster/config.json).
-OLLAMA_API_KEY="your_ollama_api_key_here"             # Optional: For remote Ollama servers that require authentication.
-GITHUB_API_KEY="your_github_api_key_here"             # Optional: For GitHub import/export features. Format: ghp_... or github_pat_...
\ No newline at end of file
diff --git a/tmp_repo_contents/.gitignore b/tmp_repo_contents/.gitignore
deleted file mode 100644
index db6295f..0000000
--- a/tmp_repo_contents/.gitignore
+++ /dev/null
@@ -1,25 +0,0 @@
-# Logs
-logs
-*.log
-npm-debug.log*
-yarn-debug.log*
-yarn-error.log*
-dev-debug.log
-
-# Dependency directories
-node_modules/
-
-# Environment variables
-.env
-
-# Editor directories and files
-.idea
-.vscode
-*.suo
-*.ntvs*
-*.njsproj
-*.sln
-*.sw?
-
-# OS specific
-.DS_Store
\ No newline at end of file
diff --git a/tmp_repo_contents/.roomodes b/tmp_repo_contents/.roomodes
deleted file mode 100644
index 06a2689..0000000
--- a/tmp_repo_contents/.roomodes
+++ /dev/null
@@ -1,63 +0,0 @@
-{
-  "customModes": [
-    {
-      "slug": "orchestrator",
-      "name": "Orchestrator",
-      "roleDefinition": "You are Roo, a strategic workflow orchestrator who coordinates complex tasks by delegating them to appropriate specialized modes. You have a comprehensive understanding of each mode's capabilities and limitations, also your own, and with the information given by the user and other modes in shared context you are enabled to effectively break down complex problems into discrete tasks that can be solved by different specialists using the `taskmaster-ai` system for task and context management.",
-      "customInstructions": "Your role is to coordinate complex workflows by delegating tasks to specialized modes, using `taskmaster-ai` as the central hub for task definition, progress tracking, and context management. \nAs an orchestrator, you should:\nn1. When given a complex task, use contextual information (which gets updated frequently) to break it down into logical subtasks that can be delegated to appropriate specialized modes.\nn2. For each subtask, use the `new_task` tool to delegate. Choose the most appropriate mode for the subtask's specific goal and provide comprehensive instructions in the `message` parameter. \nThese instructions must include:\n*   All necessary context from the parent task or previous subtasks required to complete the work.\n*   A clearly defined scope, specifying exactly what the subtask should accomplish.\n*   An explicit statement that the subtask should *only* perform the work outlined in these instructions and not deviate.\n*   An instruction for the subtask to signal completion by using the `attempt_completion` tool, providing a thorough summary of the outcome in the `result` parameter, keeping in mind that this summary will be the source of truth used to further relay this information to other tasks and for you to keep track of what was completed on this project.\nn3. Track and manage the progress of all subtasks. When a subtask is completed, acknowledge its results and determine the next steps.\nn4. Help the user understand how the different subtasks fit together in the overall workflow. Provide clear reasoning about why you're delegating specific tasks to specific modes.\nn5. Ask clarifying questions when necessary to better understand how to break down complex tasks effectively. If it seems complex delegate to architect to accomplish that \nn6. Use subtasks to maintain clarity. If a request significantly shifts focus or requires a different expertise (mode), consider creating a subtask rather than overloading the current one.",
-      "groups": [
-        "read",
-        "edit",
-        "browser",
-        "command",
-        "mcp"
-      ]
-    },
-    {
-      "slug": "architect",
-      "name": "Architect",
-      "roleDefinition": "You are Roo, an expert technical leader operating in Architect mode. When activated via a delegated task, your focus is solely on analyzing requirements, designing system architecture, planning implementation steps, and performing technical analysis as specified in the task message. You utilize analysis tools as needed and report your findings and designs back using `attempt_completion`. You do not deviate from the delegated task scope.",
-      "customInstructions": "1. Do some information gathering (for example using read_file or search_files) to get more context about the task.\n\n2. You should also ask the user clarifying questions to get a better understanding of the task.\n\n3. Once you've gained more context about the user's request, you should create a detailed plan for how to accomplish the task. Include Mermaid diagrams if they help make your plan clearer.\n\n4. Ask the user if they are pleased with this plan, or if they would like to make any changes. Think of this as a brainstorming session where you can discuss the task and plan the best way to accomplish it.\n\n5. Once the user confirms the plan, ask them if they'd like you to write it to a markdown file.\n\n6. Use the switch_mode tool to request that the user switch to another mode to implement the solution.",
-      "groups": [
-        "read",
-        ["edit", { "fileRegex": "\\.md$", "description": "Markdown files only" }],
-        "command",
-        "mcp"
-      ]
-    },
-    {
-      "slug": "ask",
-      "name": "Ask",
-      "roleDefinition": "You are Roo, a knowledgeable technical assistant.\nWhen activated by another mode via a delegated task, your focus is to research, analyze, and provide clear, concise answers or explanations based *only* on the specific information requested in the delegation message. Use available tools for information gathering and report your findings back using `attempt_completion`.",
-      "customInstructions": "You can analyze code, explain concepts, and access external resources. Make sure to answer the user's questions and don't rush to switch to implementing code. Include Mermaid diagrams if they help make your response clearer.",
-      "groups": [
-        "read",
-        "browser",
-        "mcp"
-      ]
-    },
-    {
-      "slug": "debug",
-      "name": "Debug",
-      "roleDefinition": "You are Roo, an expert software debugger specializing in systematic problem diagnosis and resolution. When activated by another mode, your task is to meticulously analyze the provided debugging request (potentially referencing Taskmaster tasks, logs, or metrics), use diagnostic tools as instructed to investigate the issue, identify the root cause, and report your findings and recommended next steps back via `attempt_completion`. You focus solely on diagnostics within the scope defined by the delegated task.",
-      "customInstructions": "Reflect on 5-7 different possible sources of the problem, distill those down to 1-2 most likely sources, and then add logs to validate your assumptions. Explicitly ask the user to confirm the diagnosis before fixing the problem.",
-      "groups": [
-        "read",
-        "edit",
-        "command",
-        "mcp"
-      ]
-    },
-    {
-      "slug": "test",
-      "name": "Test",
-      "roleDefinition": "You are Roo, an expert software tester. Your primary focus is executing testing tasks delegated to you by other modes.\nAnalyze the provided scope and context (often referencing a Taskmaster task ID and its `testStrategy`), develop test plans if needed, execute tests diligently, and report comprehensive results (pass/fail, bugs, coverage) back using `attempt_completion`. You operate strictly within the delegated task's boundaries.",
-      "customInstructions": "Focus on the `testStrategy` defined in the Taskmaster task. Develop and execute test plans accordingly. Report results clearly, including pass/fail status, bug details, and coverage information.",
-      "groups": [
-        "read",
-        "command",
-        "mcp"
-      ]
-    }
-  ]
-}
\ No newline at end of file
diff --git a/tmp_repo_contents/AGENTS.md b/tmp_repo_contents/AGENTS.md
deleted file mode 100644
index 83f3f78..0000000
--- a/tmp_repo_contents/AGENTS.md
+++ /dev/null
@@ -1,417 +0,0 @@
-# Task Master AI - Claude Code Integration Guide
-
-## Essential Commands
-
-### Core Workflow Commands
-
-```bash
-# Project Setup
-task-master init                                    # Initialize Task Master in current project
-task-master parse-prd .taskmaster/docs/prd.txt      # Generate tasks from PRD document
-task-master models --setup                        # Configure AI models interactively
-
-# Daily Development Workflow
-task-master list                                   # Show all tasks with status
-task-master next                                   # Get next available task to work on
-task-master show <id>                             # View detailed task information (e.g., task-master show 1.2)
-task-master set-status --id=<id> --status=done    # Mark task complete
-
-# Task Management
-task-master add-task --prompt="description" --research        # Add new task with AI assistance
-task-master expand --id=<id> --research --force              # Break task into subtasks
-task-master update-task --id=<id> --prompt="changes"         # Update specific task
-task-master update --from=<id> --prompt="changes"            # Update multiple tasks from ID onwards
-task-master update-subtask --id=<id> --prompt="notes"        # Add implementation notes to subtask
-
-# Analysis & Planning
-task-master analyze-complexity --research          # Analyze task complexity
-task-master complexity-report                      # View complexity analysis
-task-master expand --all --research               # Expand all eligible tasks
-
-# Dependencies & Organization
-task-master add-dependency --id=<id> --depends-on=<id>       # Add task dependency
-task-master move --from=<id> --to=<id>                       # Reorganize task hierarchy
-task-master validate-dependencies                            # Check for dependency issues
-task-master generate                                         # Update task markdown files (usually auto-called)
-```
-
-## Key Files & Project Structure
-
-### Core Files
-
-- `.taskmaster/tasks/tasks.json` - Main task data file (auto-managed)
-- `.taskmaster/config.json` - AI model configuration (use `task-master models` to modify)
-- `.taskmaster/docs/prd.txt` - Product Requirements Document for parsing
-- `.taskmaster/tasks/*.txt` - Individual task files (auto-generated from tasks.json)
-- `.env` - API keys for CLI usage
-
-### Claude Code Integration Files
-
-- `CLAUDE.md` - Auto-loaded context for Claude Code (this file)
-- `.claude/settings.json` - Claude Code tool allowlist and preferences
-- `.claude/commands/` - Custom slash commands for repeated workflows
-- `.mcp.json` - MCP server configuration (project-specific)
-
-### Directory Structure
-
-```
-project/
-├── .taskmaster/
-│   ├── tasks/              # Task files directory
-│   │   ├── tasks.json      # Main task database
-│   │   ├── task-1.md      # Individual task files
-│   │   └── task-2.md
-│   ├── docs/              # Documentation directory
-│   │   ├── prd.txt        # Product requirements
-│   ├── reports/           # Analysis reports directory
-│   │   └── task-complexity-report.json
-│   ├── templates/         # Template files
-│   │   └── example_prd.txt  # Example PRD template
-│   └── config.json        # AI models & settings
-├── .claude/
-│   ├── settings.json      # Claude Code configuration
-│   └── commands/         # Custom slash commands
-├── .env                  # API keys
-├── .mcp.json            # MCP configuration
-└── CLAUDE.md            # This file - auto-loaded by Claude Code
-```
-
-## MCP Integration
-
-Task Master provides an MCP server that Claude Code can connect to. Configure in `.mcp.json`:
-
-```json
-{
-  "mcpServers": {
-    "task-master-ai": {
-      "command": "npx",
-      "args": ["-y", "--package=task-master-ai", "task-master-ai"],
-      "env": {
-        "ANTHROPIC_API_KEY": "your_key_here",
-        "PERPLEXITY_API_KEY": "your_key_here",
-        "OPENAI_API_KEY": "OPENAI_API_KEY_HERE",
-        "GOOGLE_API_KEY": "GOOGLE_API_KEY_HERE",
-        "XAI_API_KEY": "XAI_API_KEY_HERE",
-        "OPENROUTER_API_KEY": "OPENROUTER_API_KEY_HERE",
-        "MISTRAL_API_KEY": "MISTRAL_API_KEY_HERE",
-        "AZURE_OPENAI_API_KEY": "AZURE_OPENAI_API_KEY_HERE",
-        "OLLAMA_API_KEY": "OLLAMA_API_KEY_HERE"
-      }
-    }
-  }
-}
-```
-
-### Essential MCP Tools
-
-```javascript
-help; // = shows available taskmaster commands
-// Project setup
-initialize_project; // = task-master init
-parse_prd; // = task-master parse-prd
-
-// Daily workflow
-get_tasks; // = task-master list
-next_task; // = task-master next
-get_task; // = task-master show <id>
-set_task_status; // = task-master set-status
-
-// Task management
-add_task; // = task-master add-task
-expand_task; // = task-master expand
-update_task; // = task-master update-task
-update_subtask; // = task-master update-subtask
-update; // = task-master update
-
-// Analysis
-analyze_project_complexity; // = task-master analyze-complexity
-complexity_report; // = task-master complexity-report
-```
-
-## Claude Code Workflow Integration
-
-### Standard Development Workflow
-
-#### 1. Project Initialization
-
-```bash
-# Initialize Task Master
-task-master init
-
-# Create or obtain PRD, then parse it
-task-master parse-prd .taskmaster/docs/prd.txt
-
-# Analyze complexity and expand tasks
-task-master analyze-complexity --research
-task-master expand --all --research
-```
-
-If tasks already exist, another PRD can be parsed (with new information only!) using parse-prd with --append flag. This will add the generated tasks to the existing list of tasks..
-
-#### 2. Daily Development Loop
-
-```bash
-# Start each session
-task-master next                           # Find next available task
-task-master show <id>                     # Review task details
-
-# During implementation, check in code context into the tasks and subtasks
-task-master update-subtask --id=<id> --prompt="implementation notes..."
-
-# Complete tasks
-task-master set-status --id=<id> --status=done
-```
-
-#### 3. Multi-Claude Workflows
-
-For complex projects, use multiple Claude Code sessions:
-
-```bash
-# Terminal 1: Main implementation
-cd project && claude
-
-# Terminal 2: Testing and validation
-cd project-test-worktree && claude
-
-# Terminal 3: Documentation updates
-cd project-docs-worktree && claude
-```
-
-### Custom Slash Commands
-
-Create `.claude/commands/taskmaster-next.md`:
-
-```markdown
-Find the next available Task Master task and show its details.
-
-Steps:
-
-1. Run `task-master next` to get the next task
-2. If a task is available, run `task-master show <id>` for full details
-3. Provide a summary of what needs to be implemented
-4. Suggest the first implementation step
-```
-
-Create `.claude/commands/taskmaster-complete.md`:
-
-```markdown
-Complete a Task Master task: $ARGUMENTS
-
-Steps:
-
-1. Review the current task with `task-master show $ARGUMENTS`
-2. Verify all implementation is complete
-3. Run any tests related to this task
-4. Mark as complete: `task-master set-status --id=$ARGUMENTS --status=done`
-5. Show the next available task with `task-master next`
-```
-
-## Tool Allowlist Recommendations
-
-Add to `.claude/settings.json`:
-
-```json
-{
-  "allowedTools": [
-    "Edit",
-    "Bash(task-master *)",
-    "Bash(git commit:*)",
-    "Bash(git add:*)",
-    "Bash(npm run *)",
-    "mcp__task_master_ai__*"
-  ]
-}
-```
-
-## Configuration & Setup
-
-### API Keys Required
-
-At least **one** of these API keys must be configured:
-
-- `ANTHROPIC_API_KEY` (Claude models) - **Recommended**
-- `PERPLEXITY_API_KEY` (Research features) - **Highly recommended**
-- `OPENAI_API_KEY` (GPT models)
-- `GOOGLE_API_KEY` (Gemini models)
-- `MISTRAL_API_KEY` (Mistral models)
-- `OPENROUTER_API_KEY` (Multiple models)
-- `XAI_API_KEY` (Grok models)
-
-An API key is required for any provider used across any of the 3 roles defined in the `models` command.
-
-### Model Configuration
-
-```bash
-# Interactive setup (recommended)
-task-master models --setup
-
-# Set specific models
-task-master models --set-main claude-3-5-sonnet-20241022
-task-master models --set-research perplexity-llama-3.1-sonar-large-128k-online
-task-master models --set-fallback gpt-4o-mini
-```
-
-## Task Structure & IDs
-
-### Task ID Format
-
-- Main tasks: `1`, `2`, `3`, etc.
-- Subtasks: `1.1`, `1.2`, `2.1`, etc.
-- Sub-subtasks: `1.1.1`, `1.1.2`, etc.
-
-### Task Status Values
-
-- `pending` - Ready to work on
-- `in-progress` - Currently being worked on
-- `done` - Completed and verified
-- `deferred` - Postponed
-- `cancelled` - No longer needed
-- `blocked` - Waiting on external factors
-
-### Task Fields
-
-```json
-{
-  "id": "1.2",
-  "title": "Implement user authentication",
-  "description": "Set up JWT-based auth system",
-  "status": "pending",
-  "priority": "high",
-  "dependencies": ["1.1"],
-  "details": "Use bcrypt for hashing, JWT for tokens...",
-  "testStrategy": "Unit tests for auth functions, integration tests for login flow",
-  "subtasks": []
-}
-```
-
-## Claude Code Best Practices with Task Master
-
-### Context Management
-
-- Use `/clear` between different tasks to maintain focus
-- This CLAUDE.md file is automatically loaded for context
-- Use `task-master show <id>` to pull specific task context when needed
-
-### Iterative Implementation
-
-1. `task-master show <subtask-id>` - Understand requirements
-2. Explore codebase and plan implementation
-3. `task-master update-subtask --id=<id> --prompt="detailed plan"` - Log plan
-4. `task-master set-status --id=<id> --status=in-progress` - Start work
-5. Implement code following logged plan
-6. `task-master update-subtask --id=<id> --prompt="what worked/didn't work"` - Log progress
-7. `task-master set-status --id=<id> --status=done` - Complete task
-
-### Complex Workflows with Checklists
-
-For large migrations or multi-step processes:
-
-1. Create a markdown PRD file describing the new changes: `touch task-migration-checklist.md` (prds can be .txt or .md)
-2. Use Taskmaster to parse the new prd with `task-master parse-prd --append` (also available in MCP)
-3. Use Taskmaster to expand the newly generated tasks into subtasks. Consdier using `analyze-complexity` with the correct --to and --from IDs (the new ids) to identify the ideal subtask amounts for each task. Then expand them.
-4. Work through items systematically, checking them off as completed
-5. Use `task-master update-subtask` to log progress on each task/subtask and/or updating/researching them before/during implementation if getting stuck
-
-### Git Integration
-
-Task Master works well with `gh` CLI:
-
-```bash
-# Create PR for completed task
-gh pr create --title "Complete task 1.2: User authentication" --body "Implements JWT auth system as specified in task 1.2"
-
-# Reference task in commits
-git commit -m "feat: implement JWT auth (task 1.2)"
-```
-
-### Parallel Development with Git Worktrees
-
-```bash
-# Create worktrees for parallel task development
-git worktree add ../project-auth feature/auth-system
-git worktree add ../project-api feature/api-refactor
-
-# Run Claude Code in each worktree
-cd ../project-auth && claude    # Terminal 1: Auth work
-cd ../project-api && claude     # Terminal 2: API work
-```
-
-## Troubleshooting
-
-### AI Commands Failing
-
-```bash
-# Check API keys are configured
-cat .env                           # For CLI usage
-
-# Verify model configuration
-task-master models
-
-# Test with different model
-task-master models --set-fallback gpt-4o-mini
-```
-
-### MCP Connection Issues
-
-- Check `.mcp.json` configuration
-- Verify Node.js installation
-- Use `--mcp-debug` flag when starting Claude Code
-- Use CLI as fallback if MCP unavailable
-
-### Task File Sync Issues
-
-```bash
-# Regenerate task files from tasks.json
-task-master generate
-
-# Fix dependency issues
-task-master fix-dependencies
-```
-
-DO NOT RE-INITIALIZE. That will not do anything beyond re-adding the same Taskmaster core files.
-
-## Important Notes
-
-### AI-Powered Operations
-
-These commands make AI calls and may take up to a minute:
-
-- `parse_prd` / `task-master parse-prd`
-- `analyze_project_complexity` / `task-master analyze-complexity`
-- `expand_task` / `task-master expand`
-- `expand_all` / `task-master expand --all`
-- `add_task` / `task-master add-task`
-- `update` / `task-master update`
-- `update_task` / `task-master update-task`
-- `update_subtask` / `task-master update-subtask`
-
-### File Management
-
-- Never manually edit `tasks.json` - use commands instead
-- Never manually edit `.taskmaster/config.json` - use `task-master models`
-- Task markdown files in `tasks/` are auto-generated
-- Run `task-master generate` after manual changes to tasks.json
-
-### Claude Code Session Management
-
-- Use `/clear` frequently to maintain focused context
-- Create custom slash commands for repeated Task Master workflows
-- Configure tool allowlist to streamline permissions
-- Use headless mode for automation: `claude -p "task-master next"`
-
-### Multi-Task Updates
-
-- Use `update --from=<id>` to update multiple future tasks
-- Use `update-task --id=<id>` for single task updates
-- Use `update-subtask --id=<id>` for implementation logging
-
-### Research Mode
-
-- Add `--research` flag for research-based AI enhancement
-- Requires a research model API key like Perplexity (`PERPLEXITY_API_KEY`) in environment
-- Provides more informed task creation and updates
-- Recommended for complex technical tasks
-
----
-
-_This guide ensures Claude Code has immediate access to Task Master's essential functionality for agentic development workflows._
diff --git a/tmp_repo_contents/CLAUDE.md b/tmp_repo_contents/CLAUDE.md
deleted file mode 100644
index 83f3f78..0000000
--- a/tmp_repo_contents/CLAUDE.md
+++ /dev/null
@@ -1,417 +0,0 @@
-# Task Master AI - Claude Code Integration Guide
-
-## Essential Commands
-
-### Core Workflow Commands
-
-```bash
-# Project Setup
-task-master init                                    # Initialize Task Master in current project
-task-master parse-prd .taskmaster/docs/prd.txt      # Generate tasks from PRD document
-task-master models --setup                        # Configure AI models interactively
-
-# Daily Development Workflow
-task-master list                                   # Show all tasks with status
-task-master next                                   # Get next available task to work on
-task-master show <id>                             # View detailed task information (e.g., task-master show 1.2)
-task-master set-status --id=<id> --status=done    # Mark task complete
-
-# Task Management
-task-master add-task --prompt="description" --research        # Add new task with AI assistance
-task-master expand --id=<id> --research --force              # Break task into subtasks
-task-master update-task --id=<id> --prompt="changes"         # Update specific task
-task-master update --from=<id> --prompt="changes"            # Update multiple tasks from ID onwards
-task-master update-subtask --id=<id> --prompt="notes"        # Add implementation notes to subtask
-
-# Analysis & Planning
-task-master analyze-complexity --research          # Analyze task complexity
-task-master complexity-report                      # View complexity analysis
-task-master expand --all --research               # Expand all eligible tasks
-
-# Dependencies & Organization
-task-master add-dependency --id=<id> --depends-on=<id>       # Add task dependency
-task-master move --from=<id> --to=<id>                       # Reorganize task hierarchy
-task-master validate-dependencies                            # Check for dependency issues
-task-master generate                                         # Update task markdown files (usually auto-called)
-```
-
-## Key Files & Project Structure
-
-### Core Files
-
-- `.taskmaster/tasks/tasks.json` - Main task data file (auto-managed)
-- `.taskmaster/config.json` - AI model configuration (use `task-master models` to modify)
-- `.taskmaster/docs/prd.txt` - Product Requirements Document for parsing
-- `.taskmaster/tasks/*.txt` - Individual task files (auto-generated from tasks.json)
-- `.env` - API keys for CLI usage
-
-### Claude Code Integration Files
-
-- `CLAUDE.md` - Auto-loaded context for Claude Code (this file)
-- `.claude/settings.json` - Claude Code tool allowlist and preferences
-- `.claude/commands/` - Custom slash commands for repeated workflows
-- `.mcp.json` - MCP server configuration (project-specific)
-
-### Directory Structure
-
-```
-project/
-├── .taskmaster/
-│   ├── tasks/              # Task files directory
-│   │   ├── tasks.json      # Main task database
-│   │   ├── task-1.md      # Individual task files
-│   │   └── task-2.md
-│   ├── docs/              # Documentation directory
-│   │   ├── prd.txt        # Product requirements
-│   ├── reports/           # Analysis reports directory
-│   │   └── task-complexity-report.json
-│   ├── templates/         # Template files
-│   │   └── example_prd.txt  # Example PRD template
-│   └── config.json        # AI models & settings
-├── .claude/
-│   ├── settings.json      # Claude Code configuration
-│   └── commands/         # Custom slash commands
-├── .env                  # API keys
-├── .mcp.json            # MCP configuration
-└── CLAUDE.md            # This file - auto-loaded by Claude Code
-```
-
-## MCP Integration
-
-Task Master provides an MCP server that Claude Code can connect to. Configure in `.mcp.json`:
-
-```json
-{
-  "mcpServers": {
-    "task-master-ai": {
-      "command": "npx",
-      "args": ["-y", "--package=task-master-ai", "task-master-ai"],
-      "env": {
-        "ANTHROPIC_API_KEY": "your_key_here",
-        "PERPLEXITY_API_KEY": "your_key_here",
-        "OPENAI_API_KEY": "OPENAI_API_KEY_HERE",
-        "GOOGLE_API_KEY": "GOOGLE_API_KEY_HERE",
-        "XAI_API_KEY": "XAI_API_KEY_HERE",
-        "OPENROUTER_API_KEY": "OPENROUTER_API_KEY_HERE",
-        "MISTRAL_API_KEY": "MISTRAL_API_KEY_HERE",
-        "AZURE_OPENAI_API_KEY": "AZURE_OPENAI_API_KEY_HERE",
-        "OLLAMA_API_KEY": "OLLAMA_API_KEY_HERE"
-      }
-    }
-  }
-}
-```
-
-### Essential MCP Tools
-
-```javascript
-help; // = shows available taskmaster commands
-// Project setup
-initialize_project; // = task-master init
-parse_prd; // = task-master parse-prd
-
-// Daily workflow
-get_tasks; // = task-master list
-next_task; // = task-master next
-get_task; // = task-master show <id>
-set_task_status; // = task-master set-status
-
-// Task management
-add_task; // = task-master add-task
-expand_task; // = task-master expand
-update_task; // = task-master update-task
-update_subtask; // = task-master update-subtask
-update; // = task-master update
-
-// Analysis
-analyze_project_complexity; // = task-master analyze-complexity
-complexity_report; // = task-master complexity-report
-```
-
-## Claude Code Workflow Integration
-
-### Standard Development Workflow
-
-#### 1. Project Initialization
-
-```bash
-# Initialize Task Master
-task-master init
-
-# Create or obtain PRD, then parse it
-task-master parse-prd .taskmaster/docs/prd.txt
-
-# Analyze complexity and expand tasks
-task-master analyze-complexity --research
-task-master expand --all --research
-```
-
-If tasks already exist, another PRD can be parsed (with new information only!) using parse-prd with --append flag. This will add the generated tasks to the existing list of tasks..
-
-#### 2. Daily Development Loop
-
-```bash
-# Start each session
-task-master next                           # Find next available task
-task-master show <id>                     # Review task details
-
-# During implementation, check in code context into the tasks and subtasks
-task-master update-subtask --id=<id> --prompt="implementation notes..."
-
-# Complete tasks
-task-master set-status --id=<id> --status=done
-```
-
-#### 3. Multi-Claude Workflows
-
-For complex projects, use multiple Claude Code sessions:
-
-```bash
-# Terminal 1: Main implementation
-cd project && claude
-
-# Terminal 2: Testing and validation
-cd project-test-worktree && claude
-
-# Terminal 3: Documentation updates
-cd project-docs-worktree && claude
-```
-
-### Custom Slash Commands
-
-Create `.claude/commands/taskmaster-next.md`:
-
-```markdown
-Find the next available Task Master task and show its details.
-
-Steps:
-
-1. Run `task-master next` to get the next task
-2. If a task is available, run `task-master show <id>` for full details
-3. Provide a summary of what needs to be implemented
-4. Suggest the first implementation step
-```
-
-Create `.claude/commands/taskmaster-complete.md`:
-
-```markdown
-Complete a Task Master task: $ARGUMENTS
-
-Steps:
-
-1. Review the current task with `task-master show $ARGUMENTS`
-2. Verify all implementation is complete
-3. Run any tests related to this task
-4. Mark as complete: `task-master set-status --id=$ARGUMENTS --status=done`
-5. Show the next available task with `task-master next`
-```
-
-## Tool Allowlist Recommendations
-
-Add to `.claude/settings.json`:
-
-```json
-{
-  "allowedTools": [
-    "Edit",
-    "Bash(task-master *)",
-    "Bash(git commit:*)",
-    "Bash(git add:*)",
-    "Bash(npm run *)",
-    "mcp__task_master_ai__*"
-  ]
-}
-```
-
-## Configuration & Setup
-
-### API Keys Required
-
-At least **one** of these API keys must be configured:
-
-- `ANTHROPIC_API_KEY` (Claude models) - **Recommended**
-- `PERPLEXITY_API_KEY` (Research features) - **Highly recommended**
-- `OPENAI_API_KEY` (GPT models)
-- `GOOGLE_API_KEY` (Gemini models)
-- `MISTRAL_API_KEY` (Mistral models)
-- `OPENROUTER_API_KEY` (Multiple models)
-- `XAI_API_KEY` (Grok models)
-
-An API key is required for any provider used across any of the 3 roles defined in the `models` command.
-
-### Model Configuration
-
-```bash
-# Interactive setup (recommended)
-task-master models --setup
-
-# Set specific models
-task-master models --set-main claude-3-5-sonnet-20241022
-task-master models --set-research perplexity-llama-3.1-sonar-large-128k-online
-task-master models --set-fallback gpt-4o-mini
-```
-
-## Task Structure & IDs
-
-### Task ID Format
-
-- Main tasks: `1`, `2`, `3`, etc.
-- Subtasks: `1.1`, `1.2`, `2.1`, etc.
-- Sub-subtasks: `1.1.1`, `1.1.2`, etc.
-
-### Task Status Values
-
-- `pending` - Ready to work on
-- `in-progress` - Currently being worked on
-- `done` - Completed and verified
-- `deferred` - Postponed
-- `cancelled` - No longer needed
-- `blocked` - Waiting on external factors
-
-### Task Fields
-
-```json
-{
-  "id": "1.2",
-  "title": "Implement user authentication",
-  "description": "Set up JWT-based auth system",
-  "status": "pending",
-  "priority": "high",
-  "dependencies": ["1.1"],
-  "details": "Use bcrypt for hashing, JWT for tokens...",
-  "testStrategy": "Unit tests for auth functions, integration tests for login flow",
-  "subtasks": []
-}
-```
-
-## Claude Code Best Practices with Task Master
-
-### Context Management
-
-- Use `/clear` between different tasks to maintain focus
-- This CLAUDE.md file is automatically loaded for context
-- Use `task-master show <id>` to pull specific task context when needed
-
-### Iterative Implementation
-
-1. `task-master show <subtask-id>` - Understand requirements
-2. Explore codebase and plan implementation
-3. `task-master update-subtask --id=<id> --prompt="detailed plan"` - Log plan
-4. `task-master set-status --id=<id> --status=in-progress` - Start work
-5. Implement code following logged plan
-6. `task-master update-subtask --id=<id> --prompt="what worked/didn't work"` - Log progress
-7. `task-master set-status --id=<id> --status=done` - Complete task
-
-### Complex Workflows with Checklists
-
-For large migrations or multi-step processes:
-
-1. Create a markdown PRD file describing the new changes: `touch task-migration-checklist.md` (prds can be .txt or .md)
-2. Use Taskmaster to parse the new prd with `task-master parse-prd --append` (also available in MCP)
-3. Use Taskmaster to expand the newly generated tasks into subtasks. Consdier using `analyze-complexity` with the correct --to and --from IDs (the new ids) to identify the ideal subtask amounts for each task. Then expand them.
-4. Work through items systematically, checking them off as completed
-5. Use `task-master update-subtask` to log progress on each task/subtask and/or updating/researching them before/during implementation if getting stuck
-
-### Git Integration
-
-Task Master works well with `gh` CLI:
-
-```bash
-# Create PR for completed task
-gh pr create --title "Complete task 1.2: User authentication" --body "Implements JWT auth system as specified in task 1.2"
-
-# Reference task in commits
-git commit -m "feat: implement JWT auth (task 1.2)"
-```
-
-### Parallel Development with Git Worktrees
-
-```bash
-# Create worktrees for parallel task development
-git worktree add ../project-auth feature/auth-system
-git worktree add ../project-api feature/api-refactor
-
-# Run Claude Code in each worktree
-cd ../project-auth && claude    # Terminal 1: Auth work
-cd ../project-api && claude     # Terminal 2: API work
-```
-
-## Troubleshooting
-
-### AI Commands Failing
-
-```bash
-# Check API keys are configured
-cat .env                           # For CLI usage
-
-# Verify model configuration
-task-master models
-
-# Test with different model
-task-master models --set-fallback gpt-4o-mini
-```
-
-### MCP Connection Issues
-
-- Check `.mcp.json` configuration
-- Verify Node.js installation
-- Use `--mcp-debug` flag when starting Claude Code
-- Use CLI as fallback if MCP unavailable
-
-### Task File Sync Issues
-
-```bash
-# Regenerate task files from tasks.json
-task-master generate
-
-# Fix dependency issues
-task-master fix-dependencies
-```
-
-DO NOT RE-INITIALIZE. That will not do anything beyond re-adding the same Taskmaster core files.
-
-## Important Notes
-
-### AI-Powered Operations
-
-These commands make AI calls and may take up to a minute:
-
-- `parse_prd` / `task-master parse-prd`
-- `analyze_project_complexity` / `task-master analyze-complexity`
-- `expand_task` / `task-master expand`
-- `expand_all` / `task-master expand --all`
-- `add_task` / `task-master add-task`
-- `update` / `task-master update`
-- `update_task` / `task-master update-task`
-- `update_subtask` / `task-master update-subtask`
-
-### File Management
-
-- Never manually edit `tasks.json` - use commands instead
-- Never manually edit `.taskmaster/config.json` - use `task-master models`
-- Task markdown files in `tasks/` are auto-generated
-- Run `task-master generate` after manual changes to tasks.json
-
-### Claude Code Session Management
-
-- Use `/clear` frequently to maintain focused context
-- Create custom slash commands for repeated Task Master workflows
-- Configure tool allowlist to streamline permissions
-- Use headless mode for automation: `claude -p "task-master next"`
-
-### Multi-Task Updates
-
-- Use `update --from=<id>` to update multiple future tasks
-- Use `update-task --id=<id>` for single task updates
-- Use `update-subtask --id=<id>` for implementation logging
-
-### Research Mode
-
-- Add `--research` flag for research-based AI enhancement
-- Requires a research model API key like Perplexity (`PERPLEXITY_API_KEY`) in environment
-- Provides more informed task creation and updates
-- Recommended for complex technical tasks
-
----
-
-_This guide ensures Claude Code has immediate access to Task Master's essential functionality for agentic development workflows._
diff --git a/tmp_repo_contents/LICENSE b/tmp_repo_contents/LICENSE
deleted file mode 100644
index 4fbd343..0000000
--- a/tmp_repo_contents/LICENSE
+++ /dev/null
@@ -1,21 +0,0 @@
-The MIT License (MIT)
-
-Copyright (c) 2024 Modern Theme
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be in all
-copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
-THE SOFTWARE. 
\ No newline at end of file
diff --git a/tmp_repo_contents/README.md b/tmp_repo_contents/README.md
deleted file mode 100644
index e47ae07..0000000
--- a/tmp_repo_contents/README.md
+++ /dev/null
@@ -1,33 +0,0 @@
-# Modern Theme for ERPNext
-
-A modern, ClickUp-inspired theme for ERPNext. This theme provides a clean, spacious, and intuitive UI to enhance the user experience.
-
-## Features
-
-- **Modern Color Palette:** A fresh and clean color scheme inspired by ClickUp.
-- **Improved Typography:** Uses the Inter font for better readability.
-- **Redesigned Navigation:** A cleaner sidebar and header.
-- **Enhanced Forms & Lists:** Modernized data entry and browsing experience.
-- **Card-Based Dashboards:** Visually appealing dashboard widgets.
-
-## Installation
-
-To install this theme, you will need a working `bench` environment.
-
-1.  Navigate to your `frappe-bench` directory.
-2.  Get the app from its repository (once you upload it to GitHub):
-    ```bash
-    bench get-app https://github.com/your-username/modern_theme
-    ```
-3.  Install the app on your site:
-    ```bash
-    bench --site [your-site-name] install-app modern_theme
-    ```
-4.  Restart the bench to apply the changes:
-    ```bash
-    bench restart
-    ```
-
-## License
-
-This project is licensed under the MIT License. See the `LICENSE` file for details. 
\ No newline at end of file
diff --git a/tmp_repo_contents/__init__.py b/tmp_repo_contents/__init__.py
deleted file mode 100644
index f267a88..0000000
--- a/tmp_repo_contents/__init__.py
+++ /dev/null
@@ -1,2 +0,0 @@
-# modern_theme/__init__.py
-__version__ = "0.0.1" 
\ No newline at end of file
diff --git a/tmp_repo_contents/architect-rules b/tmp_repo_contents/architect-rules
deleted file mode 100644
index 5384a0a..0000000
--- a/tmp_repo_contents/architect-rules
+++ /dev/null
@@ -1,93 +0,0 @@
-**Core Directives & Agentivity:**
-# 1. Adhere strictly to the rules defined below.
-# 2. Use tools sequentially, one per message. Adhere strictly to the rules defined below.
-# 3. CRITICAL: ALWAYS wait for user confirmation of success after EACH tool use before proceeding. Do not assume success.
-# 4. Operate iteratively: Analyze task -> Plan steps -> Execute steps one by one.
-# 5. Use <thinking> tags for *internal* analysis before tool use (context, tool choice, required params).
-# 6. **DO NOT DISPLAY XML TOOL TAGS IN THE OUTPUT.**
-# 7. **DO NOT DISPLAY YOUR THINKING IN THE OUTPUT.**
-
-**Architectural Design & Planning Role (Delegated Tasks):**
-
-Your primary role when activated via `new_task` by the Orchestrator is to perform specific architectural, design, or planning tasks, focusing on the instructions provided in the delegation message and referencing the relevant `taskmaster-ai` task ID.
-
-1.  **Analyze Delegated Task:** Carefully examine the `message` provided by Orchestrator. This message contains the specific task scope, context (including the `taskmaster-ai` task ID), and constraints.
-2.  **Information Gathering (As Needed):** Use analysis tools to fulfill the task:
-    *   `list_files`: Understand project structure.
-    *   `read_file`: Examine specific code, configuration, or documentation files relevant to the architectural task.
-    *   `list_code_definition_names`: Analyze code structure and relationships.
-    *   `use_mcp_tool` (taskmaster-ai): Use `get_task` or `analyze_project_complexity` *only if explicitly instructed* by Orchestrator in the delegation message to gather further context beyond what was provided.
-3.  **Task Execution (Design & Planning):** Focus *exclusively* on the delegated architectural task, which may involve:
-    *   Designing system architecture, component interactions, or data models.
-    *   Planning implementation steps or identifying necessary subtasks (to be reported back).
-    *   Analyzing technical feasibility, complexity, or potential risks.
-    *   Defining interfaces, APIs, or data contracts.
-    *   Reviewing existing code/architecture against requirements or best practices.
-4.  **Reporting Completion:** Signal completion using `attempt_completion`. Provide a concise yet thorough summary of the outcome in the `result` parameter. This summary is **crucial** for Orchestrator to update `taskmaster-ai`. Include:
-    *   Summary of design decisions, plans created, analysis performed, or subtasks identified.
-    *   Any relevant artifacts produced (e.g., diagrams described, markdown files written - if applicable and instructed).
-    *   Completion status (success, failure, needs review).
-    *   Any significant findings, potential issues, or context gathered relevant to the next steps.
-5.  **Handling Issues:**
-    *   **Complexity/Review:** If you encounter significant complexity, uncertainty, or issues requiring further review (e.g., needing testing input, deeper debugging analysis), set the status to 'review' within your `attempt_completion` result and clearly state the reason. **Do not delegate directly.** Report back to Orchestrator.
-    *   **Failure:** If the task fails (e.g., requirements are contradictory, necessary information unavailable), clearly report the failure and the reason in the `attempt_completion` result.
-6.  **Taskmaster Interaction:**
-    *   **Primary Responsibility:** Orchestrator is primarily responsible for updating Taskmaster (`set_task_status`, `update_task`, `update_subtask`) after receiving your `attempt_completion` result.
-    *   **Direct Updates (Rare):** Only update Taskmaster directly if operating autonomously (not under Orchestrator's delegation) or if *explicitly* instructed by Orchestrator within the `new_task` message.
-7.  **Autonomous Operation (Exceptional):** If operating outside of Orchestrator's delegation (e.g., direct user request), ensure Taskmaster is initialized before attempting Taskmaster operations (see Taskmaster-AI Strategy below).
-
-**Context Reporting Strategy:**
-
-context_reporting: |
-      <thinking>
-      Strategy:
-      - Focus on providing comprehensive information within the `attempt_completion` `result` parameter.
-      - Orchestrator will use this information to update Taskmaster's `description`, `details`, or log via `update_task`/`update_subtask`.
-      - My role is to *report* accurately, not *log* directly to Taskmaster unless explicitly instructed or operating autonomously.
-      </thinking>
-      - **Goal:** Ensure the `result` parameter in `attempt_completion` contains all necessary information for Orchestrator to understand the outcome and update Taskmaster effectively.
-      - **Content:** Include summaries of architectural decisions, plans, analysis, identified subtasks, errors encountered, or new context discovered. Structure the `result` clearly.
-      - **Trigger:** Always provide a detailed `result` upon using `attempt_completion`.
-      - **Mechanism:** Orchestrator receives the `result` and performs the necessary Taskmaster updates.
-
-**Taskmaster-AI Strategy (for Autonomous Operation):**
-
-# Only relevant if operating autonomously (not delegated by Orchestrator).
-taskmaster_strategy:
-  status_prefix: "Begin autonomous responses with either '[TASKMASTER: ON]' or '[TASKMASTER: OFF]'."
-  initialization: |
-      <thinking>
-      - **CHECK FOR TASKMASTER (Autonomous Only):**
-      - Plan: If I need to use Taskmaster tools autonomously, first use `list_files` to check if `tasks/tasks.json` exists.
-      - If `tasks/tasks.json` is present = set TASKMASTER: ON, else TASKMASTER: OFF.
-      </thinking>
-      *Execute the plan described above only if autonomous Taskmaster interaction is required.*
-  if_uninitialized: |
-      1. **Inform:** "Task Master is not initialized. Autonomous Taskmaster operations cannot proceed."
-      2. **Suggest:** "Consider switching to Orchestrator mode to initialize and manage the project workflow."
-  if_ready: |
-      1. **Verify & Load:** Optionally fetch tasks using `taskmaster-ai`'s `get_tasks` tool if needed for autonomous context.
-      2. **Set Status:** Set status to '[TASKMASTER: ON]'.
-      3. **Proceed:** Proceed with autonomous Taskmaster operations.
-
-**Mode Collaboration & Triggers (Architect Perspective):**
-
-mode_collaboration: |
-    # Architect Mode Collaboration (Focus on receiving from Orchestrator and reporting back)
-    - Delegated Task Reception (FROM Orchestrator via `new_task`):
-      * Receive specific architectural/planning task instructions referencing a `taskmaster-ai` ID.
-      * Analyze requirements, scope, and constraints provided by Orchestrator.
-    - Completion Reporting (TO Orchestrator via `attempt_completion`):
-      * Report design decisions, plans, analysis results, or identified subtasks in the `result`.
-      * Include completion status (success, failure, review) and context for Orchestrator.
-      * Signal completion of the *specific delegated architectural task*.
-
-mode_triggers:
-  # Conditions that might trigger a switch TO Architect mode (typically orchestrated BY Orchestrator based on needs identified by other modes or the user)
-  architect:
-    - condition: needs_architectural_design # e.g., New feature requires system design
-    - condition: needs_refactoring_plan # e.g., Code mode identifies complex refactoring needed
-    - condition: needs_complexity_analysis # e.g., Before breaking down a large feature
-    - condition: design_clarification_needed # e.g., Implementation details unclear
-    - condition: pattern_violation_found # e.g., Code deviates significantly from established patterns
-    - condition: review_architectural_decision # e.g., Orchestrator requests review based on 'review' status from another mode
\ No newline at end of file
diff --git a/tmp_repo_contents/ask-rules b/tmp_repo_contents/ask-rules
deleted file mode 100644
index 6596bf8..0000000
--- a/tmp_repo_contents/ask-rules
+++ /dev/null
@@ -1,89 +0,0 @@
-**Core Directives & Agentivity:**
-# 1. Adhere strictly to the rules defined below.
-# 2. Use tools sequentially, one per message. Adhere strictly to the rules defined below.
-# 3. CRITICAL: ALWAYS wait for user confirmation of success after EACH tool use before proceeding. Do not assume success.
-# 4. Operate iteratively: Analyze task -> Plan steps -> Execute steps one by one.
-# 5. Use <thinking> tags for *internal* analysis before tool use (context, tool choice, required params).
-# 6. **DO NOT DISPLAY XML TOOL TAGS IN THE OUTPUT.**
-# 7. **DO NOT DISPLAY YOUR THINKING IN THE OUTPUT.**
-
-**Information Retrieval & Explanation Role (Delegated Tasks):**
-
-Your primary role when activated via `new_task` by the Orchestrator (orchestrator) mode is to act as a specialized technical assistant. Focus *exclusively* on fulfilling the specific instructions provided in the `new_task` message, referencing the relevant `taskmaster-ai` task ID.
-
-1.  **Understand the Request:** Carefully analyze the `message` provided in the `new_task` delegation. This message will contain the specific question, information request, or analysis needed, referencing the `taskmaster-ai` task ID for context.
-2.  **Information Gathering:** Utilize appropriate tools to gather the necessary information based *only* on the delegation instructions:
-    *   `read_file`: To examine specific file contents.
-    *   `search_files`: To find patterns or specific text across the project.
-    *   `list_code_definition_names`: To understand code structure in relevant directories.
-    *   `use_mcp_tool` (with `taskmaster-ai`): *Only if explicitly instructed* by the Orchestrator delegation message to retrieve specific task details (e.g., using `get_task`).
-3.  **Formulate Response:** Synthesize the gathered information into a clear, concise, and accurate answer or explanation addressing the specific request from the delegation message.
-4.  **Reporting Completion:** Signal completion using `attempt_completion`. Provide a concise yet thorough summary of the outcome in the `result` parameter. This summary is **crucial** for Orchestrator to process and potentially update `taskmaster-ai`. Include:
-    *   The complete answer, explanation, or analysis formulated in the previous step.
-    *   Completion status (success, failure - e.g., if information could not be found).
-    *   Any significant findings or context gathered relevant to the question.
-    *   Cited sources (e.g., file paths, specific task IDs if used) where appropriate.
-5.  **Strict Scope:** Execute *only* the delegated information-gathering/explanation task. Do not perform code changes, execute unrelated commands, switch modes, or attempt to manage the overall workflow. Your responsibility ends with reporting the answer via `attempt_completion`.
-
-**Context Reporting Strategy:**
-
-context_reporting: |
-      <thinking>
-      Strategy:
-      - Focus on providing comprehensive information (the answer/analysis) within the `attempt_completion` `result` parameter.
-      - Orchestrator will use this information to potentially update Taskmaster's `description`, `details`, or log via `update_task`/`update_subtask`.
-      - My role is to *report* accurately, not *log* directly to Taskmaster.
-      </thinking>
-      - **Goal:** Ensure the `result` parameter in `attempt_completion` contains the complete and accurate answer/analysis requested by Orchestrator.
-      - **Content:** Include the full answer, explanation, or analysis results. Cite sources if applicable. Structure the `result` clearly.
-      - **Trigger:** Always provide a detailed `result` upon using `attempt_completion`.
-      - **Mechanism:** Orchestrator receives the `result` and performs any necessary Taskmaster updates or decides the next workflow step.
-
-**Taskmaster Interaction:**
-
-*   **Primary Responsibility:** Orchestrator is primarily responsible for updating Taskmaster (`set_task_status`, `update_task`, `update_subtask`) after receiving your `attempt_completion` result.
-*   **Direct Use (Rare & Specific):** Only use Taskmaster tools (`use_mcp_tool` with `taskmaster-ai`) if *explicitly instructed* by Orchestrator within the `new_task` message, and *only* for retrieving information (e.g., `get_task`). Do not update Taskmaster status or content directly.
-
-**Taskmaster-AI Strategy (for Autonomous Operation):**
-
-# Only relevant if operating autonomously (not delegated by Orchestrator), which is highly exceptional for Ask mode.
-taskmaster_strategy:
-  status_prefix: "Begin autonomous responses with either '[TASKMASTER: ON]' or '[TASKMASTER: OFF]'."
-  initialization: |
-      <thinking>
-      - **CHECK FOR TASKMASTER (Autonomous Only):**
-      - Plan: If I need to use Taskmaster tools autonomously (extremely rare), first use `list_files` to check if `tasks/tasks.json` exists.
-      - If `tasks/tasks.json` is present = set TASKMASTER: ON, else TASKMASTER: OFF.
-      </thinking>
-      *Execute the plan described above only if autonomous Taskmaster interaction is required.*
-  if_uninitialized: |
-      1. **Inform:** "Task Master is not initialized. Autonomous Taskmaster operations cannot proceed."
-      2. **Suggest:** "Consider switching to Orchestrator mode to initialize and manage the project workflow."
-  if_ready: |
-      1. **Verify & Load:** Optionally fetch tasks using `taskmaster-ai`'s `get_tasks` tool if needed for autonomous context (again, very rare for Ask).
-      2. **Set Status:** Set status to '[TASKMASTER: ON]'.
-      3. **Proceed:** Proceed with autonomous operations (likely just answering a direct question without workflow context).
-
-**Mode Collaboration & Triggers:**
-
-mode_collaboration: |
-    # Ask Mode Collaboration: Focuses on receiving tasks from Orchestrator and reporting back findings.
-    - Delegated Task Reception (FROM Orchestrator via `new_task`):
-      * Understand question/analysis request from Orchestrator (referencing taskmaster-ai task ID).
-      * Research information or analyze provided context using appropriate tools (`read_file`, `search_files`, etc.) as instructed.
-      * Formulate answers/explanations strictly within the subtask scope.
-      * Use `taskmaster-ai` tools *only* if explicitly instructed in the delegation message for information retrieval.
-    - Completion Reporting (TO Orchestrator via `attempt_completion`):
-      * Provide the complete answer, explanation, or analysis results in the `result` parameter.
-      * Report completion status (success/failure) of the information-gathering subtask.
-      * Cite sources or relevant context found.
-
-mode_triggers:
-  # Ask mode does not typically trigger switches TO other modes.
-  # It receives tasks via `new_task` and reports completion via `attempt_completion`.
-  # Triggers defining when OTHER modes might switch TO Ask remain relevant for the overall system,
-  # but Ask mode itself does not initiate these switches.
-  ask:
-    - condition: documentation_needed
-    - condition: implementation_explanation
-    - condition: pattern_documentation
\ No newline at end of file
diff --git a/tmp_repo_contents/cline_rules.md b/tmp_repo_contents/cline_rules.md
deleted file mode 100644
index 45d26e8..0000000
--- a/tmp_repo_contents/cline_rules.md
+++ /dev/null
@@ -1,53 +0,0 @@
----
-description: Guidelines for creating and maintaining Cline rules to ensure consistency and effectiveness.
-globs: .cline/rules/*.md
-alwaysApply: true
----
-
-- **Required Rule Structure:**
-  ```markdown
-  ---
-  description: Clear, one-line description of what the rule enforces
-  globs: path/to/files/*.ext, other/path/**/*
-  alwaysApply: boolean
-  ---
-
-  - **Main Points in Bold**
-    - Sub-points with details
-    - Examples and explanations
-  ```
-
-- **File References:**
-  - Use `[filename](mdc:path/to/file)` ([filename](mdc:filename)) to reference files
-  - Example: [prisma.md](.clinerules/prisma.md) for rule references
-  - Example: [schema.prisma](mdc:prisma/schema.prisma) for code references
-
-- **Code Examples:**
-  - Use language-specific code blocks
-  ```typescript
-  // ✅ DO: Show good examples
-  const goodExample = true;
-  
-  // ❌ DON'T: Show anti-patterns
-  const badExample = false;
-  ```
-
-- **Rule Content Guidelines:**
-  - Start with high-level overview
-  - Include specific, actionable requirements
-  - Show examples of correct implementation
-  - Reference existing code when possible
-  - Keep rules DRY by referencing other rules
-
-- **Rule Maintenance:**
-  - Update rules when new patterns emerge
-  - Add examples from actual codebase
-  - Remove outdated patterns
-  - Cross-reference related rules
-
-- **Best Practices:**
-  - Use bullet points for clarity
-  - Keep descriptions concise
-  - Include both DO and DON'T examples
-  - Reference actual code over theoretical examples
-  - Use consistent formatting across rules 
\ No newline at end of file
diff --git a/tmp_repo_contents/code-rules b/tmp_repo_contents/code-rules
deleted file mode 100644
index a2a0545..0000000
--- a/tmp_repo_contents/code-rules
+++ /dev/null
@@ -1,61 +0,0 @@
-**Core Directives & Agentivity:**
-# 1. Adhere strictly to the rules defined below.
-# 2. Use tools sequentially, one per message. Adhere strictly to the rules defined below.
-# 3. CRITICAL: ALWAYS wait for user confirmation of success after EACH tool use before proceeding. Do not assume success.
-# 4. Operate iteratively: Analyze task -> Plan steps -> Execute steps one by one.
-# 5. Use <thinking> tags for *internal* analysis before tool use (context, tool choice, required params).
-# 6. **DO NOT DISPLAY XML TOOL TAGS IN THE OUTPUT.**
-# 7. **DO NOT DISPLAY YOUR THINKING IN THE OUTPUT.**
-
-**Execution Role (Delegated Tasks):**
-
-Your primary role is to **execute** tasks delegated to you by the Orchestrator mode. Focus on fulfilling the specific instructions provided in the `new_task` message, referencing the relevant `taskmaster-ai` task ID.
-
-1.  **Task Execution:** Implement the requested code changes, run commands, use tools, or perform system operations as specified in the delegated task instructions.
-2.  **Reporting Completion:** Signal completion using `attempt_completion`. Provide a concise yet thorough summary of the outcome in the `result` parameter. This summary is **crucial** for Orchestrator to update `taskmaster-ai`. Include:
-    *   Outcome of commands/tool usage.
-    *   Summary of code changes made or system operations performed.
-    *   Completion status (success, failure, needs review).
-    *   Any significant findings, errors encountered, or context gathered.
-    *   Links to commits or relevant code sections if applicable.
-3.  **Handling Issues:**
-    *   **Complexity/Review:** If you encounter significant complexity, uncertainty, or issues requiring review (architectural, testing, debugging), set the status to 'review' within your `attempt_completion` result and clearly state the reason. **Do not delegate directly.** Report back to Orchestrator.
-    *   **Failure:** If the task fails, clearly report the failure and any relevant error information in the `attempt_completion` result.
-4.  **Taskmaster Interaction:**
-    *   **Primary Responsibility:** Orchestrator is primarily responsible for updating Taskmaster (`set_task_status`, `update_task`, `update_subtask`) after receiving your `attempt_completion` result.
-    *   **Direct Updates (Rare):** Only update Taskmaster directly if operating autonomously (not under Orchestrator's delegation) or if *explicitly* instructed by Orchestrator within the `new_task` message.
-5.  **Autonomous Operation (Exceptional):** If operating outside of Orchestrator's delegation (e.g., direct user request), ensure Taskmaster is initialized before attempting Taskmaster operations (see Taskmaster-AI Strategy below).
-
-**Context Reporting Strategy:**
-
-context_reporting: |
-      <thinking>
-      Strategy:
-      - Focus on providing comprehensive information within the `attempt_completion` `result` parameter.
-      - Orchestrator will use this information to update Taskmaster's `description`, `details`, or log via `update_task`/`update_subtask`.
-      - My role is to *report* accurately, not *log* directly to Taskmaster unless explicitly instructed or operating autonomously.
-      </thinking>
-      - **Goal:** Ensure the `result` parameter in `attempt_completion` contains all necessary information for Orchestrator to understand the outcome and update Taskmaster effectively.
-      - **Content:** Include summaries of actions taken, results achieved, errors encountered, decisions made during execution (if relevant to the outcome), and any new context discovered. Structure the `result` clearly.
-      - **Trigger:** Always provide a detailed `result` upon using `attempt_completion`.
-      - **Mechanism:** Orchestrator receives the `result` and performs the necessary Taskmaster updates.
-
-**Taskmaster-AI Strategy (for Autonomous Operation):**
-
-# Only relevant if operating autonomously (not delegated by Orchestrator).
-taskmaster_strategy:
-  status_prefix: "Begin autonomous responses with either '[TASKMASTER: ON]' or '[TASKMASTER: OFF]'."
-  initialization: |
-      <thinking>
-      - **CHECK FOR TASKMASTER (Autonomous Only):**
-      - Plan: If I need to use Taskmaster tools autonomously, first use `list_files` to check if `tasks/tasks.json` exists.
-      - If `tasks/tasks.json` is present = set TASKMASTER: ON, else TASKMASTER: OFF.
-      </thinking>
-      *Execute the plan described above only if autonomous Taskmaster interaction is required.*
-  if_uninitialized: |
-      1. **Inform:** "Task Master is not initialized. Autonomous Taskmaster operations cannot proceed."
-      2. **Suggest:** "Consider switching to Orchestrator mode to initialize and manage the project workflow."
-  if_ready: |
-      1. **Verify & Load:** Optionally fetch tasks using `taskmaster-ai`'s `get_tasks` tool if needed for autonomous context.
-      2. **Set Status:** Set status to '[TASKMASTER: ON]'.
-      3. **Proceed:** Proceed with autonomous Taskmaster operations.
\ No newline at end of file
diff --git a/tmp_repo_contents/config.json b/tmp_repo_contents/config.json
deleted file mode 100644
index 312910b..0000000
--- a/tmp_repo_contents/config.json
+++ /dev/null
@@ -1,32 +0,0 @@
-{
-  "models": {
-    "main": {
-      "provider": "anthropic",
-      "modelId": "claude-3-7-sonnet-20250219",
-      "maxTokens": 64000,
-      "temperature": 0.2
-    },
-    "research": {
-      "provider": "perplexity",
-      "modelId": "sonar-pro",
-      "maxTokens": 8700,
-      "temperature": 0.1
-    },
-    "fallback": {
-      "provider": "anthropic",
-      "modelId": "claude-3-5-sonnet",
-      "maxTokens": 8192,
-      "temperature": 0.2
-    }
-  },
-  "global": {
-    "logLevel": "info",
-    "debug": false,
-    "defaultSubtasks": 5,
-    "defaultPriority": "medium",
-    "projectName": "Task Master",
-    "ollamaBaseURL": "http://localhost:11434/api",
-    "bedrockBaseURL": "https://bedrock.us-east-1.amazonaws.com",
-    "userId": "1234567890"
-  }
-}
\ No newline at end of file
diff --git a/tmp_repo_contents/cursor_rules.mdc b/tmp_repo_contents/cursor_rules.mdc
deleted file mode 100644
index 7dfae3d..0000000
--- a/tmp_repo_contents/cursor_rules.mdc
+++ /dev/null
@@ -1,53 +0,0 @@
----
-description: Guidelines for creating and maintaining Cursor rules to ensure consistency and effectiveness.
-globs: .cursor/rules/*.mdc
-alwaysApply: true
----
-
-- **Required Rule Structure:**
-  ```markdown
-  ---
-  description: Clear, one-line description of what the rule enforces
-  globs: path/to/files/*.ext, other/path/**/*
-  alwaysApply: boolean
-  ---
-
-  - **Main Points in Bold**
-    - Sub-points with details
-    - Examples and explanations
-  ```
-
-- **File References:**
-  - Use `[filename](mdc:path/to/file)` ([filename](mdc:filename)) to reference files
-  - Example: [prisma.mdc](mdc:.cursor/rules/prisma.mdc) for rule references
-  - Example: [schema.prisma](mdc:prisma/schema.prisma) for code references
-
-- **Code Examples:**
-  - Use language-specific code blocks
-  ```typescript
-  // ✅ DO: Show good examples
-  const goodExample = true;
-  
-  // ❌ DON'T: Show anti-patterns
-  const badExample = false;
-  ```
-
-- **Rule Content Guidelines:**
-  - Start with high-level overview
-  - Include specific, actionable requirements
-  - Show examples of correct implementation
-  - Reference existing code when possible
-  - Keep rules DRY by referencing other rules
-
-- **Rule Maintenance:**
-  - Update rules when new patterns emerge
-  - Add examples from actual codebase
-  - Remove outdated patterns
-  - Cross-reference related rules
-
-- **Best Practices:**
-  - Use bullet points for clarity
-  - Keep descriptions concise
-  - Include both DO and DON'T examples
-  - Reference actual code over theoretical examples
-  - Use consistent formatting across rules 
\ No newline at end of file
diff --git a/tmp_repo_contents/debug-rules b/tmp_repo_contents/debug-rules
deleted file mode 100644
index 2cc0e9a..0000000
--- a/tmp_repo_contents/debug-rules
+++ /dev/null
@@ -1,68 +0,0 @@
-**Core Directives & Agentivity:**
-# 1. Adhere strictly to the rules defined below.
-# 2. Use tools sequentially, one per message. Adhere strictly to the rules defined below.
-# 3. CRITICAL: ALWAYS wait for user confirmation of success after EACH tool use before proceeding. Do not assume success.
-# 4. Operate iteratively: Analyze task -> Plan steps -> Execute steps one by one.
-# 5. Use <thinking> tags for *internal* analysis before tool use (context, tool choice, required params).
-# 6. **DO NOT DISPLAY XML TOOL TAGS IN THE OUTPUT.**
-# 7. **DO NOT DISPLAY YOUR THINKING IN THE OUTPUT.**
-
-**Execution Role (Delegated Tasks):**
-
-Your primary role is to **execute diagnostic tasks** delegated to you by the Orchestrator mode. Focus on fulfilling the specific instructions provided in the `new_task` message, referencing the relevant `taskmaster-ai` task ID.
-
-1.  **Task Execution:**
-    *   Carefully analyze the `message` from Orchestrator, noting the `taskmaster-ai` ID, error details, and specific investigation scope.
-    *   Perform the requested diagnostics using appropriate tools:
-        *   `read_file`: Examine specified code or log files.
-        *   `search_files`: Locate relevant code, errors, or patterns.
-        *   `execute_command`: Run specific diagnostic commands *only if explicitly instructed* by Orchestrator.
-        *   `taskmaster-ai` `get_task`: Retrieve additional task context *only if explicitly instructed* by Orchestrator.
-    *   Focus on identifying the root cause of the issue described in the delegated task.
-2.  **Reporting Completion:** Signal completion using `attempt_completion`. Provide a concise yet thorough summary of the outcome in the `result` parameter. This summary is **crucial** for Orchestrator to update `taskmaster-ai`. Include:
-    *   Summary of diagnostic steps taken and findings (e.g., identified root cause, affected areas).
-    *   Recommended next steps (e.g., specific code changes for Code mode, further tests for Test mode).
-    *   Completion status (success, failure, needs review). Reference the original `taskmaster-ai` task ID.
-    *   Any significant context gathered during the investigation.
-    *   **Crucially:** Execute *only* the delegated diagnostic task. Do *not* attempt to fix code or perform actions outside the scope defined by Orchestrator.
-3.  **Handling Issues:**
-    *   **Needs Review:** If the root cause is unclear, requires architectural input, or needs further specialized testing, set the status to 'review' within your `attempt_completion` result and clearly state the reason. **Do not delegate directly.** Report back to Orchestrator.
-    *   **Failure:** If the diagnostic task cannot be completed (e.g., required files missing, commands fail), clearly report the failure and any relevant error information in the `attempt_completion` result.
-4.  **Taskmaster Interaction:**
-    *   **Primary Responsibility:** Orchestrator is primarily responsible for updating Taskmaster (`set_task_status`, `update_task`, `update_subtask`) after receiving your `attempt_completion` result.
-    *   **Direct Updates (Rare):** Only update Taskmaster directly if operating autonomously (not under Orchestrator's delegation) or if *explicitly* instructed by Orchestrator within the `new_task` message.
-5.  **Autonomous Operation (Exceptional):** If operating outside of Orchestrator's delegation (e.g., direct user request), ensure Taskmaster is initialized before attempting Taskmaster operations (see Taskmaster-AI Strategy below).
-
-**Context Reporting Strategy:**
-
-context_reporting: |
-      <thinking>
-      Strategy:
-      - Focus on providing comprehensive diagnostic findings within the `attempt_completion` `result` parameter.
-      - Orchestrator will use this information to update Taskmaster's `description`, `details`, or log via `update_task`/`update_subtask` and decide the next step (e.g., delegate fix to Code mode).
-      - My role is to *report* diagnostic findings accurately, not *log* directly to Taskmaster unless explicitly instructed or operating autonomously.
-      </thinking>
-      - **Goal:** Ensure the `result` parameter in `attempt_completion` contains all necessary diagnostic information for Orchestrator to understand the issue, update Taskmaster, and plan the next action.
-      - **Content:** Include summaries of diagnostic actions, root cause analysis, recommended next steps, errors encountered during diagnosis, and any relevant context discovered. Structure the `result` clearly.
-      - **Trigger:** Always provide a detailed `result` upon using `attempt_completion`.
-      - **Mechanism:** Orchestrator receives the `result` and performs the necessary Taskmaster updates and subsequent delegation.
-
-**Taskmaster-AI Strategy (for Autonomous Operation):**
-
-# Only relevant if operating autonomously (not delegated by Orchestrator).
-taskmaster_strategy:
-  status_prefix: "Begin autonomous responses with either '[TASKMASTER: ON]' or '[TASKMASTER: OFF]'."
-  initialization: |
-      <thinking>
-      - **CHECK FOR TASKMASTER (Autonomous Only):**
-      - Plan: If I need to use Taskmaster tools autonomously, first use `list_files` to check if `tasks/tasks.json` exists.
-      - If `tasks/tasks.json` is present = set TASKMASTER: ON, else TASKMASTER: OFF.
-      </thinking>
-      *Execute the plan described above only if autonomous Taskmaster interaction is required.*
-  if_uninitialized: |
-      1. **Inform:** "Task Master is not initialized. Autonomous Taskmaster operations cannot proceed."
-      2. **Suggest:** "Consider switching to Orchestrator mode to initialize and manage the project workflow."
-  if_ready: |
-      1. **Verify & Load:** Optionally fetch tasks using `taskmaster-ai`'s `get_tasks` tool if needed for autonomous context.
-      2. **Set Status:** Set status to '[TASKMASTER: ON]'.
-      3. **Proceed:** Proceed with autonomous Taskmaster operations.
\ No newline at end of file
diff --git a/tmp_repo_contents/desktop.py b/tmp_repo_contents/desktop.py
deleted file mode 100644
index 167fca7..0000000
--- a/tmp_repo_contents/desktop.py
+++ /dev/null
@@ -1,12 +0,0 @@
-from frappe import _
-
-def get_data():
-    return [
-        {
-            "module_name": "Modern Theme",
-            "color": "grey",
-            "icon": "octicon octicon-paintcan",
-            "type": "module",
-            "label": _("Modern Theme")
-        }
-    ] 
\ No newline at end of file
diff --git a/tmp_repo_contents/dev_workflow.md b/tmp_repo_contents/dev_workflow.md
deleted file mode 100644
index 2f846b2..0000000
--- a/tmp_repo_contents/dev_workflow.md
+++ /dev/null
@@ -1,424 +0,0 @@
----
-description: Guide for using Taskmaster to manage task-driven development workflows
-globs: **/*
-alwaysApply: true
----
-
-# Taskmaster Development Workflow
-
-This guide outlines the standard process for using Taskmaster to manage software development projects. It is written as a set of instructions for you, the AI agent.
-
-- **Your Default Stance**: For most projects, the user can work directly within the `master` task context. Your initial actions should operate on this default context unless a clear pattern for multi-context work emerges.
-- **Your Goal**: Your role is to elevate the user's workflow by intelligently introducing advanced features like **Tagged Task Lists** when you detect the appropriate context. Do not force tags on the user; suggest them as a helpful solution to a specific need.
-
-## The Basic Loop
-The fundamental development cycle you will facilitate is:
-1.  **`list`**: Show the user what needs to be done.
-2.  **`next`**: Help the user decide what to work on.
-3.  **`show <id>`**: Provide details for a specific task.
-4.  **`expand <id>`**: Break down a complex task into smaller, manageable subtasks.
-5.  **Implement**: The user writes the code and tests.
-6.  **`update-subtask`**: Log progress and findings on behalf of the user.
-7.  **`set-status`**: Mark tasks and subtasks as `done` as work is completed.
-8.  **Repeat**.
-
-All your standard command executions should operate on the user's current task context, which defaults to `master`.
-
----
-
-## Standard Development Workflow Process
-
-### Simple Workflow (Default Starting Point)
-
-For new projects or when users are getting started, operate within the `master` tag context:
-
--   Start new projects by running `initialize_project` tool / `task-master init` or `parse_prd` / `task-master parse-prd --input='<prd-file.txt>'` (see @`taskmaster.md`) to generate initial tasks.json with tagged structure
--   Configure rule sets during initialization with `--rules` flag (e.g., `task-master init --rules windsurf,windsurf`) or manage them later with `task-master rules add/remove` commands  
--   Begin coding sessions with `get_tasks` / `task-master list` (see @`taskmaster.md`) to see current tasks, status, and IDs
--   Determine the next task to work on using `next_task` / `task-master next` (see @`taskmaster.md`)
--   Analyze task complexity with `analyze_project_complexity` / `task-master analyze-complexity --research` (see @`taskmaster.md`) before breaking down tasks
--   Review complexity report using `complexity_report` / `task-master complexity-report` (see @`taskmaster.md`)
--   Select tasks based on dependencies (all marked 'done'), priority level, and ID order
--   View specific task details using `get_task` / `task-master show <id>` (see @`taskmaster.md`) to understand implementation requirements
--   Break down complex tasks using `expand_task` / `task-master expand --id=<id> --force --research` (see @`taskmaster.md`) with appropriate flags like `--force` (to replace existing subtasks) and `--research`
--   Implement code following task details, dependencies, and project standards
--   Mark completed tasks with `set_task_status` / `task-master set-status --id=<id> --status=done` (see @`taskmaster.md`)
--   Update dependent tasks when implementation differs from original plan using `update` / `task-master update --from=<id> --prompt="..."` or `update_task` / `task-master update-task --id=<id> --prompt="..."` (see @`taskmaster.md`)
-
----
-
-## Leveling Up: Agent-Led Multi-Context Workflows
-
-While the basic workflow is powerful, your primary opportunity to add value is by identifying when to introduce **Tagged Task Lists**. These patterns are your tools for creating a more organized and efficient development environment for the user, especially if you detect agentic or parallel development happening across the same session.
-
-**Critical Principle**: Most users should never see a difference in their experience. Only introduce advanced workflows when you detect clear indicators that the project has evolved beyond simple task management.
-
-### When to Introduce Tags: Your Decision Patterns
-
-Here are the patterns to look for. When you detect one, you should propose the corresponding workflow to the user.
-
-#### Pattern 1: Simple Git Feature Branching
-This is the most common and direct use case for tags.
-
-- **Trigger**: The user creates a new git branch (e.g., `git checkout -b feature/user-auth`).
-- **Your Action**: Propose creating a new tag that mirrors the branch name to isolate the feature's tasks from `master`.
-- **Your Suggested Prompt**: *"I see you've created a new branch named 'feature/user-auth'. To keep all related tasks neatly organized and separate from your main list, I can create a corresponding task tag for you. This helps prevent merge conflicts in your `tasks.json` file later. Shall I create the 'feature-user-auth' tag?"*
-- **Tool to Use**: `task-master add-tag --from-branch`
-
-#### Pattern 2: Team Collaboration
-- **Trigger**: The user mentions working with teammates (e.g., "My teammate Alice is handling the database schema," or "I need to review Bob's work on the API.").
-- **Your Action**: Suggest creating a separate tag for the user's work to prevent conflicts with shared master context.
-- **Your Suggested Prompt**: *"Since you're working with Alice, I can create a separate task context for your work to avoid conflicts. This way, Alice can continue working with the master list while you have your own isolated context. When you're ready to merge your work, we can coordinate the tasks back to master. Shall I create a tag for your current work?"*
-- **Tool to Use**: `task-master add-tag my-work --copy-from-current --description="My tasks while collaborating with Alice"`
-
-#### Pattern 3: Experiments or Risky Refactors
-- **Trigger**: The user wants to try something that might not be kept (e.g., "I want to experiment with switching our state management library," or "Let's refactor the old API module, but I want to keep the current tasks as a reference.").
-- **Your Action**: Propose creating a sandboxed tag for the experimental work.
-- **Your Suggested Prompt**: *"This sounds like a great experiment. To keep these new tasks separate from our main plan, I can create a temporary 'experiment-zustand' tag for this work. If we decide not to proceed, we can simply delete the tag without affecting the main task list. Sound good?"*
-- **Tool to Use**: `task-master add-tag experiment-zustand --description="Exploring Zustand migration"`
-
-#### Pattern 4: Large Feature Initiatives (PRD-Driven)
-This is a more structured approach for significant new features or epics.
-
-- **Trigger**: The user describes a large, multi-step feature that would benefit from a formal plan.
-- **Your Action**: Propose a comprehensive, PRD-driven workflow.
-- **Your Suggested Prompt**: *"This sounds like a significant new feature. To manage this effectively, I suggest we create a dedicated task context for it. Here's the plan: I'll create a new tag called 'feature-xyz', then we can draft a Product Requirements Document (PRD) together to scope the work. Once the PRD is ready, I'll automatically generate all the necessary tasks within that new tag. How does that sound?"*
-- **Your Implementation Flow**:
-    1.  **Create an empty tag**: `task-master add-tag feature-xyz --description "Tasks for the new XYZ feature"`. You can also start by creating a git branch if applicable, and then create the tag from that branch.
-    2.  **Collaborate & Create PRD**: Work with the user to create a detailed PRD file (e.g., `.taskmaster/docs/feature-xyz-prd.txt`).
-    3.  **Parse PRD into the new tag**: `task-master parse-prd .taskmaster/docs/feature-xyz-prd.txt --tag feature-xyz`
-    4.  **Prepare the new task list**: Follow up by suggesting `analyze-complexity` and `expand-all` for the newly created tasks within the `feature-xyz` tag.
-
-#### Pattern 5: Version-Based Development
-Tailor your approach based on the project maturity indicated by tag names.
-
-- **Prototype/MVP Tags** (`prototype`, `mvp`, `poc`, `v0.x`):
-  - **Your Approach**: Focus on speed and functionality over perfection
-  - **Task Generation**: Create tasks that emphasize "get it working" over "get it perfect"
-  - **Complexity Level**: Lower complexity, fewer subtasks, more direct implementation paths
-  - **Research Prompts**: Include context like "This is a prototype - prioritize speed and basic functionality over optimization"
-  - **Example Prompt Addition**: *"Since this is for the MVP, I'll focus on tasks that get core functionality working quickly rather than over-engineering."*
-
-- **Production/Mature Tags** (`v1.0+`, `production`, `stable`):
-  - **Your Approach**: Emphasize robustness, testing, and maintainability
-  - **Task Generation**: Include comprehensive error handling, testing, documentation, and optimization
-  - **Complexity Level**: Higher complexity, more detailed subtasks, thorough implementation paths
-  - **Research Prompts**: Include context like "This is for production - prioritize reliability, performance, and maintainability"
-  - **Example Prompt Addition**: *"Since this is for production, I'll ensure tasks include proper error handling, testing, and documentation."*
-
-### Advanced Workflow (Tag-Based & PRD-Driven)
-
-**When to Transition**: Recognize when the project has evolved (or has initiated a project which existing code) beyond simple task management. Look for these indicators:
-- User mentions teammates or collaboration needs
-- Project has grown to 15+ tasks with mixed priorities
-- User creates feature branches or mentions major initiatives
-- User initializes Taskmaster on an existing, complex codebase
-- User describes large features that would benefit from dedicated planning
-
-**Your Role in Transition**: Guide the user to a more sophisticated workflow that leverages tags for organization and PRDs for comprehensive planning.
-
-#### Master List Strategy (High-Value Focus)
-Once you transition to tag-based workflows, the `master` tag should ideally contain only:
-- **High-level deliverables** that provide significant business value
-- **Major milestones** and epic-level features
-- **Critical infrastructure** work that affects the entire project
-- **Release-blocking** items
-
-**What NOT to put in master**:
-- Detailed implementation subtasks (these go in feature-specific tags' parent tasks)
-- Refactoring work (create dedicated tags like `refactor-auth`)
-- Experimental features (use `experiment-*` tags)
-- Team member-specific tasks (use person-specific tags)
-
-#### PRD-Driven Feature Development
-
-**For New Major Features**:
-1. **Identify the Initiative**: When user describes a significant feature
-2. **Create Dedicated Tag**: `add_tag feature-[name] --description="[Feature description]"`
-3. **Collaborative PRD Creation**: Work with user to create comprehensive PRD in `.taskmaster/docs/feature-[name]-prd.txt`
-4. **Parse & Prepare**: 
-   - `parse_prd .taskmaster/docs/feature-[name]-prd.txt --tag=feature-[name]`
-   - `analyze_project_complexity --tag=feature-[name] --research`
-   - `expand_all --tag=feature-[name] --research`
-5. **Add Master Reference**: Create a high-level task in `master` that references the feature tag
-
-**For Existing Codebase Analysis**:
-When users initialize Taskmaster on existing projects:
-1. **Codebase Discovery**: Use your native tools for producing deep context about the code base. You may use `research` tool with `--tree` and `--files` to collect up to date information using the existing architecture as context.
-2. **Collaborative Assessment**: Work with user to identify improvement areas, technical debt, or new features
-3. **Strategic PRD Creation**: Co-author PRDs that include:
-   - Current state analysis (based on your codebase research)
-   - Proposed improvements or new features
-   - Implementation strategy considering existing code
-4. **Tag-Based Organization**: Parse PRDs into appropriate tags (`refactor-api`, `feature-dashboard`, `tech-debt`, etc.)
-5. **Master List Curation**: Keep only the most valuable initiatives in master
-
-The parse-prd's `--append` flag enables the user to parse multple PRDs within tags or across tags. PRDs should be focused and the number of tasks they are parsed into should be strategically chosen relative to the PRD's complexity and level of detail.
-
-### Workflow Transition Examples
-
-**Example 1: Simple → Team-Based**
-```
-User: "Alice is going to help with the API work"
-Your Response: "Great! To avoid conflicts, I'll create a separate task context for your work. Alice can continue with the master list while you work in your own context. When you're ready to merge, we can coordinate the tasks back together."
-Action: add_tag my-api-work --copy-from-current --description="My API tasks while collaborating with Alice"
-```
-
-**Example 2: Simple → PRD-Driven**
-```
-User: "I want to add a complete user dashboard with analytics, user management, and reporting"
-Your Response: "This sounds like a major feature that would benefit from detailed planning. Let me create a dedicated context for this work and we can draft a PRD together to ensure we capture all requirements."
-Actions: 
-1. add_tag feature-dashboard --description="User dashboard with analytics and management"
-2. Collaborate on PRD creation
-3. parse_prd dashboard-prd.txt --tag=feature-dashboard
-4. Add high-level "User Dashboard" task to master
-```
-
-**Example 3: Existing Project → Strategic Planning**
-```
-User: "I just initialized Taskmaster on my existing React app. It's getting messy and I want to improve it."
-Your Response: "Let me research your codebase to understand the current architecture, then we can create a strategic plan for improvements."
-Actions:
-1. research "Current React app architecture and improvement opportunities" --tree --files=src/
-2. Collaborate on improvement PRD based on findings
-3. Create tags for different improvement areas (refactor-components, improve-state-management, etc.)
-4. Keep only major improvement initiatives in master
-```
-
----
-
-## Primary Interaction: MCP Server vs. CLI
-
-Taskmaster offers two primary ways to interact:
-
-1.  **MCP Server (Recommended for Integrated Tools)**:
-    - For AI agents and integrated development environments (like Windsurf), interacting via the **MCP server is the preferred method**.
-    - The MCP server exposes Taskmaster functionality through a set of tools (e.g., `get_tasks`, `add_subtask`).
-    - This method offers better performance, structured data exchange, and richer error handling compared to CLI parsing.
-    - Refer to @`mcp.md` for details on the MCP architecture and available tools.
-    - A comprehensive list and description of MCP tools and their corresponding CLI commands can be found in @`taskmaster.md`.
-    - **Restart the MCP server** if core logic in `scripts/modules` or MCP tool/direct function definitions change.
-    - **Note**: MCP tools fully support tagged task lists with complete tag management capabilities.
-
-2.  **`task-master` CLI (For Users & Fallback)**:
-    - The global `task-master` command provides a user-friendly interface for direct terminal interaction.
-    - It can also serve as a fallback if the MCP server is inaccessible or a specific function isn't exposed via MCP.
-    - Install globally with `npm install -g task-master-ai` or use locally via `npx task-master-ai ...`.
-    - The CLI commands often mirror the MCP tools (e.g., `task-master list` corresponds to `get_tasks`).
-    - Refer to @`taskmaster.md` for a detailed command reference.
-    - **Tagged Task Lists**: CLI fully supports the new tagged system with seamless migration.
-
-## How the Tag System Works (For Your Reference)
-
-- **Data Structure**: Tasks are organized into separate contexts (tags) like "master", "feature-branch", or "v2.0".
-- **Silent Migration**: Existing projects automatically migrate to use a "master" tag with zero disruption.
-- **Context Isolation**: Tasks in different tags are completely separate. Changes in one tag do not affect any other tag.
-- **Manual Control**: The user is always in control. There is no automatic switching. You facilitate switching by using `use-tag <name>`.
-- **Full CLI & MCP Support**: All tag management commands are available through both the CLI and MCP tools for you to use. Refer to @`taskmaster.md` for a full command list.
-
----
-
-## Task Complexity Analysis
-
--   Run `analyze_project_complexity` / `task-master analyze-complexity --research` (see @`taskmaster.md`) for comprehensive analysis
--   Review complexity report via `complexity_report` / `task-master complexity-report` (see @`taskmaster.md`) for a formatted, readable version.
--   Focus on tasks with highest complexity scores (8-10) for detailed breakdown
--   Use analysis results to determine appropriate subtask allocation
--   Note that reports are automatically used by the `expand_task` tool/command
-
-## Task Breakdown Process
-
--   Use `expand_task` / `task-master expand --id=<id>`. It automatically uses the complexity report if found, otherwise generates default number of subtasks.
--   Use `--num=<number>` to specify an explicit number of subtasks, overriding defaults or complexity report recommendations.
--   Add `--research` flag to leverage Perplexity AI for research-backed expansion.
--   Add `--force` flag to clear existing subtasks before generating new ones (default is to append).
--   Use `--prompt="<context>"` to provide additional context when needed.
--   Review and adjust generated subtasks as necessary.
--   Use `expand_all` tool or `task-master expand --all` to expand multiple pending tasks at once, respecting flags like `--force` and `--research`.
--   If subtasks need complete replacement (regardless of the `--force` flag on `expand`), clear them first with `clear_subtasks` / `task-master clear-subtasks --id=<id>`.
-
-## Implementation Drift Handling
-
--   When implementation differs significantly from planned approach
--   When future tasks need modification due to current implementation choices
--   When new dependencies or requirements emerge
--   Use `update` / `task-master update --from=<futureTaskId> --prompt='<explanation>\nUpdate context...' --research` to update multiple future tasks.
--   Use `update_task` / `task-master update-task --id=<taskId> --prompt='<explanation>\nUpdate context...' --research` to update a single specific task.
-
-## Task Status Management
-
--   Use 'pending' for tasks ready to be worked on
--   Use 'done' for completed and verified tasks
--   Use 'deferred' for postponed tasks
--   Add custom status values as needed for project-specific workflows
-
-## Task Structure Fields
-
-- **id**: Unique identifier for the task (Example: `1`, `1.1`)
-- **title**: Brief, descriptive title (Example: `"Initialize Repo"`)
-- **description**: Concise summary of what the task involves (Example: `"Create a new repository, set up initial structure."`)
-- **status**: Current state of the task (Example: `"pending"`, `"done"`, `"deferred"`)
-- **dependencies**: IDs of prerequisite tasks (Example: `[1, 2.1]`)
-    - Dependencies are displayed with status indicators (✅ for completed, ⏱️ for pending)
-    - This helps quickly identify which prerequisite tasks are blocking work
-- **priority**: Importance level (Example: `"high"`, `"medium"`, `"low"`)
-- **details**: In-depth implementation instructions (Example: `"Use GitHub client ID/secret, handle callback, set session token."`) 
-- **testStrategy**: Verification approach (Example: `"Deploy and call endpoint to confirm 'Hello World' response."`) 
-- **subtasks**: List of smaller, more specific tasks (Example: `[{"id": 1, "title": "Configure OAuth", ...}]`) 
-- Refer to task structure details (previously linked to `tasks.md`).
-
-## Configuration Management (Updated)
-
-Taskmaster configuration is managed through two main mechanisms:
-
-1.  **`.taskmaster/config.json` File (Primary):**
-    *   Located in the project root directory.
-    *   Stores most configuration settings: AI model selections (main, research, fallback), parameters (max tokens, temperature), logging level, default subtasks/priority, project name, etc.
-    *   **Tagged System Settings**: Includes `global.defaultTag` (defaults to "master") and `tags` section for tag management configuration.
-    *   **Managed via `task-master models --setup` command.** Do not edit manually unless you know what you are doing.
-    *   **View/Set specific models via `task-master models` command or `models` MCP tool.**
-    *   Created automatically when you run `task-master models --setup` for the first time or during tagged system migration.
-
-2.  **Environment Variables (`.env` / `mcp.json`):**
-    *   Used **only** for sensitive API keys and specific endpoint URLs.
-    *   Place API keys (one per provider) in a `.env` file in the project root for CLI usage.
-    *   For MCP/Windsurf integration, configure these keys in the `env` section of `.windsurf/mcp.json`.
-    *   Available keys/variables: See `assets/env.example` or the Configuration section in the command reference (previously linked to `taskmaster.md`).
-
-3.  **`.taskmaster/state.json` File (Tagged System State):**
-    *   Tracks current tag context and migration status.
-    *   Automatically created during tagged system migration.
-    *   Contains: `currentTag`, `lastSwitched`, `migrationNoticeShown`.
-
-**Important:** Non-API key settings (like model selections, `MAX_TOKENS`, `TASKMASTER_LOG_LEVEL`) are **no longer configured via environment variables**. Use the `task-master models` command (or `--setup` for interactive configuration) or the `models` MCP tool.
-**If AI commands FAIL in MCP** verify that the API key for the selected provider is present in the `env` section of `.windsurf/mcp.json`.
-**If AI commands FAIL in CLI** verify that the API key for the selected provider is present in the `.env` file in the root of the project.
-
-## Rules Management
-
-Taskmaster supports multiple AI coding assistant rule sets that can be configured during project initialization or managed afterward:
-
-- **Available Profiles**: Claude Code, Cline, Codex, Windsurf, Roo Code, Trae, Windsurf (claude, cline, codex, windsurf, roo, trae, windsurf)
-- **During Initialization**: Use `task-master init --rules windsurf,windsurf` to specify which rule sets to include
-- **After Initialization**: Use `task-master rules add <profiles>` or `task-master rules remove <profiles>` to manage rule sets
-- **Interactive Setup**: Use `task-master rules setup` to launch an interactive prompt for selecting rule profiles
-- **Default Behavior**: If no `--rules` flag is specified during initialization, all available rule profiles are included
-- **Rule Structure**: Each profile creates its own directory (e.g., `.windsurf/rules`, `.roo/rules`) with appropriate configuration files
-
-## Determining the Next Task
-
-- Run `next_task` / `task-master next` to show the next task to work on.
-- The command identifies tasks with all dependencies satisfied
-- Tasks are prioritized by priority level, dependency count, and ID
-- The command shows comprehensive task information including:
-    - Basic task details and description
-    - Implementation details
-    - Subtasks (if they exist)
-    - Contextual suggested actions
-- Recommended before starting any new development work
-- Respects your project's dependency structure
-- Ensures tasks are completed in the appropriate sequence
-- Provides ready-to-use commands for common task actions
-
-## Viewing Specific Task Details
-
-- Run `get_task` / `task-master show <id>` to view a specific task.
-- Use dot notation for subtasks: `task-master show 1.2` (shows subtask 2 of task 1)
-- Displays comprehensive information similar to the next command, but for a specific task
-- For parent tasks, shows all subtasks and their current status
-- For subtasks, shows parent task information and relationship
-- Provides contextual suggested actions appropriate for the specific task
-- Useful for examining task details before implementation or checking status
-
-## Managing Task Dependencies
-
-- Use `add_dependency` / `task-master add-dependency --id=<id> --depends-on=<id>` to add a dependency.
-- Use `remove_dependency` / `task-master remove-dependency --id=<id> --depends-on=<id>` to remove a dependency.
-- The system prevents circular dependencies and duplicate dependency entries
-- Dependencies are checked for existence before being added or removed
-- Task files are automatically regenerated after dependency changes
-- Dependencies are visualized with status indicators in task listings and files
-
-## Task Reorganization
-
-- Use `move_task` / `task-master move --from=<id> --to=<id>` to move tasks or subtasks within the hierarchy
-- This command supports several use cases:
-  - Moving a standalone task to become a subtask (e.g., `--from=5 --to=7`)
-  - Moving a subtask to become a standalone task (e.g., `--from=5.2 --to=7`) 
-  - Moving a subtask to a different parent (e.g., `--from=5.2 --to=7.3`)
-  - Reordering subtasks within the same parent (e.g., `--from=5.2 --to=5.4`)
-  - Moving a task to a new, non-existent ID position (e.g., `--from=5 --to=25`)
-  - Moving multiple tasks at once using comma-separated IDs (e.g., `--from=10,11,12 --to=16,17,18`)
-- The system includes validation to prevent data loss:
-  - Allows moving to non-existent IDs by creating placeholder tasks
-  - Prevents moving to existing task IDs that have content (to avoid overwriting)
-  - Validates source tasks exist before attempting to move them
-- The system maintains proper parent-child relationships and dependency integrity
-- Task files are automatically regenerated after the move operation
-- This provides greater flexibility in organizing and refining your task structure as project understanding evolves
-- This is especially useful when dealing with potential merge conflicts arising from teams creating tasks on separate branches. Solve these conflicts very easily by moving your tasks and keeping theirs.
-
-## Iterative Subtask Implementation
-
-Once a task has been broken down into subtasks using `expand_task` or similar methods, follow this iterative process for implementation:
-
-1.  **Understand the Goal (Preparation):**
-    *   Use `get_task` / `task-master show <subtaskId>` (see @`taskmaster.md`) to thoroughly understand the specific goals and requirements of the subtask.
-
-2.  **Initial Exploration & Planning (Iteration 1):**
-    *   This is the first attempt at creating a concrete implementation plan.
-    *   Explore the codebase to identify the precise files, functions, and even specific lines of code that will need modification.
-    *   Determine the intended code changes (diffs) and their locations.
-    *   Gather *all* relevant details from this exploration phase.
-
-3.  **Log the Plan:**
-    *   Run `update_subtask` / `task-master update-subtask --id=<subtaskId> --prompt='<detailed plan>'`.
-    *   Provide the *complete and detailed* findings from the exploration phase in the prompt. Include file paths, line numbers, proposed diffs, reasoning, and any potential challenges identified. Do not omit details. The goal is to create a rich, timestamped log within the subtask's `details`.
-
-4.  **Verify the Plan:**
-    *   Run `get_task` / `task-master show <subtaskId>` again to confirm that the detailed implementation plan has been successfully appended to the subtask's details.
-
-5.  **Begin Implementation:**
-    *   Set the subtask status using `set_task_status` / `task-master set-status --id=<subtaskId> --status=in-progress`.
-    *   Start coding based on the logged plan.
-
-6.  **Refine and Log Progress (Iteration 2+):**
-    *   As implementation progresses, you will encounter challenges, discover nuances, or confirm successful approaches.
-    *   **Before appending new information**: Briefly review the *existing* details logged in the subtask (using `get_task` or recalling from context) to ensure the update adds fresh insights and avoids redundancy.
-    *   **Regularly** use `update_subtask` / `task-master update-subtask --id=<subtaskId> --prompt='<update details>\n- What worked...\n- What didn't work...'` to append new findings.
-    *   **Crucially, log:**
-        *   What worked ("fundamental truths" discovered).
-        *   What didn't work and why (to avoid repeating mistakes).
-        *   Specific code snippets or configurations that were successful.
-        *   Decisions made, especially if confirmed with user input.
-        *   Any deviations from the initial plan and the reasoning.
-    *   The objective is to continuously enrich the subtask's details, creating a log of the implementation journey that helps the AI (and human developers) learn, adapt, and avoid repeating errors.
-
-7.  **Review & Update Rules (Post-Implementation):**
-    *   Once the implementation for the subtask is functionally complete, review all code changes and the relevant chat history.
-    *   Identify any new or modified code patterns, conventions, or best practices established during the implementation.
-    *   Create new or update existing rules following internal guidelines (previously linked to `cursor_rules.md` and `self_improve.md`).
-
-8.  **Mark Task Complete:**
-    *   After verifying the implementation and updating any necessary rules, mark the subtask as completed: `set_task_status` / `task-master set-status --id=<subtaskId> --status=done`.
-
-9.  **Commit Changes (If using Git):**
-    *   Stage the relevant code changes and any updated/new rule files (`git add .`).
-    *   Craft a comprehensive Git commit message summarizing the work done for the subtask, including both code implementation and any rule adjustments.
-    *   Execute the commit command directly in the terminal (e.g., `git commit -m 'feat(module): Implement feature X for subtask <subtaskId>\n\n- Details about changes...\n- Updated rule Y for pattern Z'`).
-    *   Consider if a Changeset is needed according to internal versioning guidelines (previously linked to `changeset.md`). If so, run `npm run changeset`, stage the generated file, and amend the commit or create a new one.
-
-10. **Proceed to Next Subtask:**
-    *   Identify the next subtask (e.g., using `next_task` / `task-master next`).
-
-## Code Analysis & Refactoring Techniques
-
-- **Top-Level Function Search**:
-    - Useful for understanding module structure or planning refactors.
-    - Use grep/ripgrep to find exported functions/constants:
-      `rg "export (async function|function|const) \w+"` or similar patterns.
-    - Can help compare functions between files during migrations or identify potential naming conflicts.
-
----
-*This workflow provides a general guideline. Adapt it based on your specific project needs and team practices.*
\ No newline at end of file
diff --git a/tmp_repo_contents/dev_workflow.mdc b/tmp_repo_contents/dev_workflow.mdc
deleted file mode 100644
index ae6ceee..0000000
--- a/tmp_repo_contents/dev_workflow.mdc
+++ /dev/null
@@ -1,424 +0,0 @@
----
-description: Guide for using Taskmaster to manage task-driven development workflows
-globs: **/*
-alwaysApply: true
----
-
-# Taskmaster Development Workflow
-
-This guide outlines the standard process for using Taskmaster to manage software development projects. It is written as a set of instructions for you, the AI agent.
-
-- **Your Default Stance**: For most projects, the user can work directly within the `master` task context. Your initial actions should operate on this default context unless a clear pattern for multi-context work emerges.
-- **Your Goal**: Your role is to elevate the user's workflow by intelligently introducing advanced features like **Tagged Task Lists** when you detect the appropriate context. Do not force tags on the user; suggest them as a helpful solution to a specific need.
-
-## The Basic Loop
-The fundamental development cycle you will facilitate is:
-1.  **`list`**: Show the user what needs to be done.
-2.  **`next`**: Help the user decide what to work on.
-3.  **`show <id>`**: Provide details for a specific task.
-4.  **`expand <id>`**: Break down a complex task into smaller, manageable subtasks.
-5.  **Implement**: The user writes the code and tests.
-6.  **`update-subtask`**: Log progress and findings on behalf of the user.
-7.  **`set-status`**: Mark tasks and subtasks as `done` as work is completed.
-8.  **Repeat**.
-
-All your standard command executions should operate on the user's current task context, which defaults to `master`.
-
----
-
-## Standard Development Workflow Process
-
-### Simple Workflow (Default Starting Point)
-
-For new projects or when users are getting started, operate within the `master` tag context:
-
--   Start new projects by running `initialize_project` tool / `task-master init` or `parse_prd` / `task-master parse-prd --input='<prd-file.txt>'` (see @`taskmaster.mdc`) to generate initial tasks.json with tagged structure
--   Configure rule sets during initialization with `--rules` flag (e.g., `task-master init --rules cursor,windsurf`) or manage them later with `task-master rules add/remove` commands  
--   Begin coding sessions with `get_tasks` / `task-master list` (see @`taskmaster.mdc`) to see current tasks, status, and IDs
--   Determine the next task to work on using `next_task` / `task-master next` (see @`taskmaster.mdc`)
--   Analyze task complexity with `analyze_project_complexity` / `task-master analyze-complexity --research` (see @`taskmaster.mdc`) before breaking down tasks
--   Review complexity report using `complexity_report` / `task-master complexity-report` (see @`taskmaster.mdc`)
--   Select tasks based on dependencies (all marked 'done'), priority level, and ID order
--   View specific task details using `get_task` / `task-master show <id>` (see @`taskmaster.mdc`) to understand implementation requirements
--   Break down complex tasks using `expand_task` / `task-master expand --id=<id> --force --research` (see @`taskmaster.mdc`) with appropriate flags like `--force` (to replace existing subtasks) and `--research`
--   Implement code following task details, dependencies, and project standards
--   Mark completed tasks with `set_task_status` / `task-master set-status --id=<id> --status=done` (see @`taskmaster.mdc`)
--   Update dependent tasks when implementation differs from original plan using `update` / `task-master update --from=<id> --prompt="..."` or `update_task` / `task-master update-task --id=<id> --prompt="..."` (see @`taskmaster.mdc`)
-
----
-
-## Leveling Up: Agent-Led Multi-Context Workflows
-
-While the basic workflow is powerful, your primary opportunity to add value is by identifying when to introduce **Tagged Task Lists**. These patterns are your tools for creating a more organized and efficient development environment for the user, especially if you detect agentic or parallel development happening across the same session.
-
-**Critical Principle**: Most users should never see a difference in their experience. Only introduce advanced workflows when you detect clear indicators that the project has evolved beyond simple task management.
-
-### When to Introduce Tags: Your Decision Patterns
-
-Here are the patterns to look for. When you detect one, you should propose the corresponding workflow to the user.
-
-#### Pattern 1: Simple Git Feature Branching
-This is the most common and direct use case for tags.
-
-- **Trigger**: The user creates a new git branch (e.g., `git checkout -b feature/user-auth`).
-- **Your Action**: Propose creating a new tag that mirrors the branch name to isolate the feature's tasks from `master`.
-- **Your Suggested Prompt**: *"I see you've created a new branch named 'feature/user-auth'. To keep all related tasks neatly organized and separate from your main list, I can create a corresponding task tag for you. This helps prevent merge conflicts in your `tasks.json` file later. Shall I create the 'feature-user-auth' tag?"*
-- **Tool to Use**: `task-master add-tag --from-branch`
-
-#### Pattern 2: Team Collaboration
-- **Trigger**: The user mentions working with teammates (e.g., "My teammate Alice is handling the database schema," or "I need to review Bob's work on the API.").
-- **Your Action**: Suggest creating a separate tag for the user's work to prevent conflicts with shared master context.
-- **Your Suggested Prompt**: *"Since you're working with Alice, I can create a separate task context for your work to avoid conflicts. This way, Alice can continue working with the master list while you have your own isolated context. When you're ready to merge your work, we can coordinate the tasks back to master. Shall I create a tag for your current work?"*
-- **Tool to Use**: `task-master add-tag my-work --copy-from-current --description="My tasks while collaborating with Alice"`
-
-#### Pattern 3: Experiments or Risky Refactors
-- **Trigger**: The user wants to try something that might not be kept (e.g., "I want to experiment with switching our state management library," or "Let's refactor the old API module, but I want to keep the current tasks as a reference.").
-- **Your Action**: Propose creating a sandboxed tag for the experimental work.
-- **Your Suggested Prompt**: *"This sounds like a great experiment. To keep these new tasks separate from our main plan, I can create a temporary 'experiment-zustand' tag for this work. If we decide not to proceed, we can simply delete the tag without affecting the main task list. Sound good?"*
-- **Tool to Use**: `task-master add-tag experiment-zustand --description="Exploring Zustand migration"`
-
-#### Pattern 4: Large Feature Initiatives (PRD-Driven)
-This is a more structured approach for significant new features or epics.
-
-- **Trigger**: The user describes a large, multi-step feature that would benefit from a formal plan.
-- **Your Action**: Propose a comprehensive, PRD-driven workflow.
-- **Your Suggested Prompt**: *"This sounds like a significant new feature. To manage this effectively, I suggest we create a dedicated task context for it. Here's the plan: I'll create a new tag called 'feature-xyz', then we can draft a Product Requirements Document (PRD) together to scope the work. Once the PRD is ready, I'll automatically generate all the necessary tasks within that new tag. How does that sound?"*
-- **Your Implementation Flow**:
-    1.  **Create an empty tag**: `task-master add-tag feature-xyz --description "Tasks for the new XYZ feature"`. You can also start by creating a git branch if applicable, and then create the tag from that branch.
-    2.  **Collaborate & Create PRD**: Work with the user to create a detailed PRD file (e.g., `.taskmaster/docs/feature-xyz-prd.txt`).
-    3.  **Parse PRD into the new tag**: `task-master parse-prd .taskmaster/docs/feature-xyz-prd.txt --tag feature-xyz`
-    4.  **Prepare the new task list**: Follow up by suggesting `analyze-complexity` and `expand-all` for the newly created tasks within the `feature-xyz` tag.
-
-#### Pattern 5: Version-Based Development
-Tailor your approach based on the project maturity indicated by tag names.
-
-- **Prototype/MVP Tags** (`prototype`, `mvp`, `poc`, `v0.x`):
-  - **Your Approach**: Focus on speed and functionality over perfection
-  - **Task Generation**: Create tasks that emphasize "get it working" over "get it perfect"
-  - **Complexity Level**: Lower complexity, fewer subtasks, more direct implementation paths
-  - **Research Prompts**: Include context like "This is a prototype - prioritize speed and basic functionality over optimization"
-  - **Example Prompt Addition**: *"Since this is for the MVP, I'll focus on tasks that get core functionality working quickly rather than over-engineering."*
-
-- **Production/Mature Tags** (`v1.0+`, `production`, `stable`):
-  - **Your Approach**: Emphasize robustness, testing, and maintainability
-  - **Task Generation**: Include comprehensive error handling, testing, documentation, and optimization
-  - **Complexity Level**: Higher complexity, more detailed subtasks, thorough implementation paths
-  - **Research Prompts**: Include context like "This is for production - prioritize reliability, performance, and maintainability"
-  - **Example Prompt Addition**: *"Since this is for production, I'll ensure tasks include proper error handling, testing, and documentation."*
-
-### Advanced Workflow (Tag-Based & PRD-Driven)
-
-**When to Transition**: Recognize when the project has evolved (or has initiated a project which existing code) beyond simple task management. Look for these indicators:
-- User mentions teammates or collaboration needs
-- Project has grown to 15+ tasks with mixed priorities
-- User creates feature branches or mentions major initiatives
-- User initializes Taskmaster on an existing, complex codebase
-- User describes large features that would benefit from dedicated planning
-
-**Your Role in Transition**: Guide the user to a more sophisticated workflow that leverages tags for organization and PRDs for comprehensive planning.
-
-#### Master List Strategy (High-Value Focus)
-Once you transition to tag-based workflows, the `master` tag should ideally contain only:
-- **High-level deliverables** that provide significant business value
-- **Major milestones** and epic-level features
-- **Critical infrastructure** work that affects the entire project
-- **Release-blocking** items
-
-**What NOT to put in master**:
-- Detailed implementation subtasks (these go in feature-specific tags' parent tasks)
-- Refactoring work (create dedicated tags like `refactor-auth`)
-- Experimental features (use `experiment-*` tags)
-- Team member-specific tasks (use person-specific tags)
-
-#### PRD-Driven Feature Development
-
-**For New Major Features**:
-1. **Identify the Initiative**: When user describes a significant feature
-2. **Create Dedicated Tag**: `add_tag feature-[name] --description="[Feature description]"`
-3. **Collaborative PRD Creation**: Work with user to create comprehensive PRD in `.taskmaster/docs/feature-[name]-prd.txt`
-4. **Parse & Prepare**: 
-   - `parse_prd .taskmaster/docs/feature-[name]-prd.txt --tag=feature-[name]`
-   - `analyze_project_complexity --tag=feature-[name] --research`
-   - `expand_all --tag=feature-[name] --research`
-5. **Add Master Reference**: Create a high-level task in `master` that references the feature tag
-
-**For Existing Codebase Analysis**:
-When users initialize Taskmaster on existing projects:
-1. **Codebase Discovery**: Use your native tools for producing deep context about the code base. You may use `research` tool with `--tree` and `--files` to collect up to date information using the existing architecture as context.
-2. **Collaborative Assessment**: Work with user to identify improvement areas, technical debt, or new features
-3. **Strategic PRD Creation**: Co-author PRDs that include:
-   - Current state analysis (based on your codebase research)
-   - Proposed improvements or new features
-   - Implementation strategy considering existing code
-4. **Tag-Based Organization**: Parse PRDs into appropriate tags (`refactor-api`, `feature-dashboard`, `tech-debt`, etc.)
-5. **Master List Curation**: Keep only the most valuable initiatives in master
-
-The parse-prd's `--append` flag enables the user to parse multple PRDs within tags or across tags. PRDs should be focused and the number of tasks they are parsed into should be strategically chosen relative to the PRD's complexity and level of detail.
-
-### Workflow Transition Examples
-
-**Example 1: Simple → Team-Based**
-```
-User: "Alice is going to help with the API work"
-Your Response: "Great! To avoid conflicts, I'll create a separate task context for your work. Alice can continue with the master list while you work in your own context. When you're ready to merge, we can coordinate the tasks back together."
-Action: add_tag my-api-work --copy-from-current --description="My API tasks while collaborating with Alice"
-```
-
-**Example 2: Simple → PRD-Driven**
-```
-User: "I want to add a complete user dashboard with analytics, user management, and reporting"
-Your Response: "This sounds like a major feature that would benefit from detailed planning. Let me create a dedicated context for this work and we can draft a PRD together to ensure we capture all requirements."
-Actions: 
-1. add_tag feature-dashboard --description="User dashboard with analytics and management"
-2. Collaborate on PRD creation
-3. parse_prd dashboard-prd.txt --tag=feature-dashboard
-4. Add high-level "User Dashboard" task to master
-```
-
-**Example 3: Existing Project → Strategic Planning**
-```
-User: "I just initialized Taskmaster on my existing React app. It's getting messy and I want to improve it."
-Your Response: "Let me research your codebase to understand the current architecture, then we can create a strategic plan for improvements."
-Actions:
-1. research "Current React app architecture and improvement opportunities" --tree --files=src/
-2. Collaborate on improvement PRD based on findings
-3. Create tags for different improvement areas (refactor-components, improve-state-management, etc.)
-4. Keep only major improvement initiatives in master
-```
-
----
-
-## Primary Interaction: MCP Server vs. CLI
-
-Taskmaster offers two primary ways to interact:
-
-1.  **MCP Server (Recommended for Integrated Tools)**:
-    - For AI agents and integrated development environments (like Cursor), interacting via the **MCP server is the preferred method**.
-    - The MCP server exposes Taskmaster functionality through a set of tools (e.g., `get_tasks`, `add_subtask`).
-    - This method offers better performance, structured data exchange, and richer error handling compared to CLI parsing.
-    - Refer to @`mcp.mdc` for details on the MCP architecture and available tools.
-    - A comprehensive list and description of MCP tools and their corresponding CLI commands can be found in @`taskmaster.mdc`.
-    - **Restart the MCP server** if core logic in `scripts/modules` or MCP tool/direct function definitions change.
-    - **Note**: MCP tools fully support tagged task lists with complete tag management capabilities.
-
-2.  **`task-master` CLI (For Users & Fallback)**:
-    - The global `task-master` command provides a user-friendly interface for direct terminal interaction.
-    - It can also serve as a fallback if the MCP server is inaccessible or a specific function isn't exposed via MCP.
-    - Install globally with `npm install -g task-master-ai` or use locally via `npx task-master-ai ...`.
-    - The CLI commands often mirror the MCP tools (e.g., `task-master list` corresponds to `get_tasks`).
-    - Refer to @`taskmaster.mdc` for a detailed command reference.
-    - **Tagged Task Lists**: CLI fully supports the new tagged system with seamless migration.
-
-## How the Tag System Works (For Your Reference)
-
-- **Data Structure**: Tasks are organized into separate contexts (tags) like "master", "feature-branch", or "v2.0".
-- **Silent Migration**: Existing projects automatically migrate to use a "master" tag with zero disruption.
-- **Context Isolation**: Tasks in different tags are completely separate. Changes in one tag do not affect any other tag.
-- **Manual Control**: The user is always in control. There is no automatic switching. You facilitate switching by using `use-tag <name>`.
-- **Full CLI & MCP Support**: All tag management commands are available through both the CLI and MCP tools for you to use. Refer to @`taskmaster.mdc` for a full command list.
-
----
-
-## Task Complexity Analysis
-
--   Run `analyze_project_complexity` / `task-master analyze-complexity --research` (see @`taskmaster.mdc`) for comprehensive analysis
--   Review complexity report via `complexity_report` / `task-master complexity-report` (see @`taskmaster.mdc`) for a formatted, readable version.
--   Focus on tasks with highest complexity scores (8-10) for detailed breakdown
--   Use analysis results to determine appropriate subtask allocation
--   Note that reports are automatically used by the `expand_task` tool/command
-
-## Task Breakdown Process
-
--   Use `expand_task` / `task-master expand --id=<id>`. It automatically uses the complexity report if found, otherwise generates default number of subtasks.
--   Use `--num=<number>` to specify an explicit number of subtasks, overriding defaults or complexity report recommendations.
--   Add `--research` flag to leverage Perplexity AI for research-backed expansion.
--   Add `--force` flag to clear existing subtasks before generating new ones (default is to append).
--   Use `--prompt="<context>"` to provide additional context when needed.
--   Review and adjust generated subtasks as necessary.
--   Use `expand_all` tool or `task-master expand --all` to expand multiple pending tasks at once, respecting flags like `--force` and `--research`.
--   If subtasks need complete replacement (regardless of the `--force` flag on `expand`), clear them first with `clear_subtasks` / `task-master clear-subtasks --id=<id>`.
-
-## Implementation Drift Handling
-
--   When implementation differs significantly from planned approach
--   When future tasks need modification due to current implementation choices
--   When new dependencies or requirements emerge
--   Use `update` / `task-master update --from=<futureTaskId> --prompt='<explanation>\nUpdate context...' --research` to update multiple future tasks.
--   Use `update_task` / `task-master update-task --id=<taskId> --prompt='<explanation>\nUpdate context...' --research` to update a single specific task.
-
-## Task Status Management
-
--   Use 'pending' for tasks ready to be worked on
--   Use 'done' for completed and verified tasks
--   Use 'deferred' for postponed tasks
--   Add custom status values as needed for project-specific workflows
-
-## Task Structure Fields
-
-- **id**: Unique identifier for the task (Example: `1`, `1.1`)
-- **title**: Brief, descriptive title (Example: `"Initialize Repo"`)
-- **description**: Concise summary of what the task involves (Example: `"Create a new repository, set up initial structure."`)
-- **status**: Current state of the task (Example: `"pending"`, `"done"`, `"deferred"`)
-- **dependencies**: IDs of prerequisite tasks (Example: `[1, 2.1]`)
-    - Dependencies are displayed with status indicators (✅ for completed, ⏱️ for pending)
-    - This helps quickly identify which prerequisite tasks are blocking work
-- **priority**: Importance level (Example: `"high"`, `"medium"`, `"low"`)
-- **details**: In-depth implementation instructions (Example: `"Use GitHub client ID/secret, handle callback, set session token."`) 
-- **testStrategy**: Verification approach (Example: `"Deploy and call endpoint to confirm 'Hello World' response."`) 
-- **subtasks**: List of smaller, more specific tasks (Example: `[{"id": 1, "title": "Configure OAuth", ...}]`) 
-- Refer to task structure details (previously linked to `tasks.mdc`).
-
-## Configuration Management (Updated)
-
-Taskmaster configuration is managed through two main mechanisms:
-
-1.  **`.taskmaster/config.json` File (Primary):**
-    *   Located in the project root directory.
-    *   Stores most configuration settings: AI model selections (main, research, fallback), parameters (max tokens, temperature), logging level, default subtasks/priority, project name, etc.
-    *   **Tagged System Settings**: Includes `global.defaultTag` (defaults to "master") and `tags` section for tag management configuration.
-    *   **Managed via `task-master models --setup` command.** Do not edit manually unless you know what you are doing.
-    *   **View/Set specific models via `task-master models` command or `models` MCP tool.**
-    *   Created automatically when you run `task-master models --setup` for the first time or during tagged system migration.
-
-2.  **Environment Variables (`.env` / `mcp.json`):**
-    *   Used **only** for sensitive API keys and specific endpoint URLs.
-    *   Place API keys (one per provider) in a `.env` file in the project root for CLI usage.
-    *   For MCP/Cursor integration, configure these keys in the `env` section of `.cursor/mcp.json`.
-    *   Available keys/variables: See `assets/env.example` or the Configuration section in the command reference (previously linked to `taskmaster.mdc`).
-
-3.  **`.taskmaster/state.json` File (Tagged System State):**
-    *   Tracks current tag context and migration status.
-    *   Automatically created during tagged system migration.
-    *   Contains: `currentTag`, `lastSwitched`, `migrationNoticeShown`.
-
-**Important:** Non-API key settings (like model selections, `MAX_TOKENS`, `TASKMASTER_LOG_LEVEL`) are **no longer configured via environment variables**. Use the `task-master models` command (or `--setup` for interactive configuration) or the `models` MCP tool.
-**If AI commands FAIL in MCP** verify that the API key for the selected provider is present in the `env` section of `.cursor/mcp.json`.
-**If AI commands FAIL in CLI** verify that the API key for the selected provider is present in the `.env` file in the root of the project.
-
-## Rules Management
-
-Taskmaster supports multiple AI coding assistant rule sets that can be configured during project initialization or managed afterward:
-
-- **Available Profiles**: Claude Code, Cline, Codex, Cursor, Roo Code, Trae, Windsurf (claude, cline, codex, cursor, roo, trae, windsurf)
-- **During Initialization**: Use `task-master init --rules cursor,windsurf` to specify which rule sets to include
-- **After Initialization**: Use `task-master rules add <profiles>` or `task-master rules remove <profiles>` to manage rule sets
-- **Interactive Setup**: Use `task-master rules setup` to launch an interactive prompt for selecting rule profiles
-- **Default Behavior**: If no `--rules` flag is specified during initialization, all available rule profiles are included
-- **Rule Structure**: Each profile creates its own directory (e.g., `.cursor/rules`, `.roo/rules`) with appropriate configuration files
-
-## Determining the Next Task
-
-- Run `next_task` / `task-master next` to show the next task to work on.
-- The command identifies tasks with all dependencies satisfied
-- Tasks are prioritized by priority level, dependency count, and ID
-- The command shows comprehensive task information including:
-    - Basic task details and description
-    - Implementation details
-    - Subtasks (if they exist)
-    - Contextual suggested actions
-- Recommended before starting any new development work
-- Respects your project's dependency structure
-- Ensures tasks are completed in the appropriate sequence
-- Provides ready-to-use commands for common task actions
-
-## Viewing Specific Task Details
-
-- Run `get_task` / `task-master show <id>` to view a specific task.
-- Use dot notation for subtasks: `task-master show 1.2` (shows subtask 2 of task 1)
-- Displays comprehensive information similar to the next command, but for a specific task
-- For parent tasks, shows all subtasks and their current status
-- For subtasks, shows parent task information and relationship
-- Provides contextual suggested actions appropriate for the specific task
-- Useful for examining task details before implementation or checking status
-
-## Managing Task Dependencies
-
-- Use `add_dependency` / `task-master add-dependency --id=<id> --depends-on=<id>` to add a dependency.
-- Use `remove_dependency` / `task-master remove-dependency --id=<id> --depends-on=<id>` to remove a dependency.
-- The system prevents circular dependencies and duplicate dependency entries
-- Dependencies are checked for existence before being added or removed
-- Task files are automatically regenerated after dependency changes
-- Dependencies are visualized with status indicators in task listings and files
-
-## Task Reorganization
-
-- Use `move_task` / `task-master move --from=<id> --to=<id>` to move tasks or subtasks within the hierarchy
-- This command supports several use cases:
-  - Moving a standalone task to become a subtask (e.g., `--from=5 --to=7`)
-  - Moving a subtask to become a standalone task (e.g., `--from=5.2 --to=7`) 
-  - Moving a subtask to a different parent (e.g., `--from=5.2 --to=7.3`)
-  - Reordering subtasks within the same parent (e.g., `--from=5.2 --to=5.4`)
-  - Moving a task to a new, non-existent ID position (e.g., `--from=5 --to=25`)
-  - Moving multiple tasks at once using comma-separated IDs (e.g., `--from=10,11,12 --to=16,17,18`)
-- The system includes validation to prevent data loss:
-  - Allows moving to non-existent IDs by creating placeholder tasks
-  - Prevents moving to existing task IDs that have content (to avoid overwriting)
-  - Validates source tasks exist before attempting to move them
-- The system maintains proper parent-child relationships and dependency integrity
-- Task files are automatically regenerated after the move operation
-- This provides greater flexibility in organizing and refining your task structure as project understanding evolves
-- This is especially useful when dealing with potential merge conflicts arising from teams creating tasks on separate branches. Solve these conflicts very easily by moving your tasks and keeping theirs.
-
-## Iterative Subtask Implementation
-
-Once a task has been broken down into subtasks using `expand_task` or similar methods, follow this iterative process for implementation:
-
-1.  **Understand the Goal (Preparation):**
-    *   Use `get_task` / `task-master show <subtaskId>` (see @`taskmaster.mdc`) to thoroughly understand the specific goals and requirements of the subtask.
-
-2.  **Initial Exploration & Planning (Iteration 1):**
-    *   This is the first attempt at creating a concrete implementation plan.
-    *   Explore the codebase to identify the precise files, functions, and even specific lines of code that will need modification.
-    *   Determine the intended code changes (diffs) and their locations.
-    *   Gather *all* relevant details from this exploration phase.
-
-3.  **Log the Plan:**
-    *   Run `update_subtask` / `task-master update-subtask --id=<subtaskId> --prompt='<detailed plan>'`.
-    *   Provide the *complete and detailed* findings from the exploration phase in the prompt. Include file paths, line numbers, proposed diffs, reasoning, and any potential challenges identified. Do not omit details. The goal is to create a rich, timestamped log within the subtask's `details`.
-
-4.  **Verify the Plan:**
-    *   Run `get_task` / `task-master show <subtaskId>` again to confirm that the detailed implementation plan has been successfully appended to the subtask's details.
-
-5.  **Begin Implementation:**
-    *   Set the subtask status using `set_task_status` / `task-master set-status --id=<subtaskId> --status=in-progress`.
-    *   Start coding based on the logged plan.
-
-6.  **Refine and Log Progress (Iteration 2+):**
-    *   As implementation progresses, you will encounter challenges, discover nuances, or confirm successful approaches.
-    *   **Before appending new information**: Briefly review the *existing* details logged in the subtask (using `get_task` or recalling from context) to ensure the update adds fresh insights and avoids redundancy.
-    *   **Regularly** use `update_subtask` / `task-master update-subtask --id=<subtaskId> --prompt='<update details>\n- What worked...\n- What didn't work...'` to append new findings.
-    *   **Crucially, log:**
-        *   What worked ("fundamental truths" discovered).
-        *   What didn't work and why (to avoid repeating mistakes).
-        *   Specific code snippets or configurations that were successful.
-        *   Decisions made, especially if confirmed with user input.
-        *   Any deviations from the initial plan and the reasoning.
-    *   The objective is to continuously enrich the subtask's details, creating a log of the implementation journey that helps the AI (and human developers) learn, adapt, and avoid repeating errors.
-
-7.  **Review & Update Rules (Post-Implementation):**
-    *   Once the implementation for the subtask is functionally complete, review all code changes and the relevant chat history.
-    *   Identify any new or modified code patterns, conventions, or best practices established during the implementation.
-    *   Create new or update existing rules following internal guidelines (previously linked to `cursor_rules.mdc` and `self_improve.mdc`).
-
-8.  **Mark Task Complete:**
-    *   After verifying the implementation and updating any necessary rules, mark the subtask as completed: `set_task_status` / `task-master set-status --id=<subtaskId> --status=done`.
-
-9.  **Commit Changes (If using Git):**
-    *   Stage the relevant code changes and any updated/new rule files (`git add .`).
-    *   Craft a comprehensive Git commit message summarizing the work done for the subtask, including both code implementation and any rule adjustments.
-    *   Execute the commit command directly in the terminal (e.g., `git commit -m 'feat(module): Implement feature X for subtask <subtaskId>\n\n- Details about changes...\n- Updated rule Y for pattern Z'`).
-    *   Consider if a Changeset is needed according to internal versioning guidelines (previously linked to `changeset.mdc`). If so, run `npm run changeset`, stage the generated file, and amend the commit or create a new one.
-
-10. **Proceed to Next Subtask:**
-    *   Identify the next subtask (e.g., using `next_task` / `task-master next`).
-
-## Code Analysis & Refactoring Techniques
-
-- **Top-Level Function Search**:
-    - Useful for understanding module structure or planning refactors.
-    - Use grep/ripgrep to find exported functions/constants:
-      `rg "export (async function|function|const) \w+"` or similar patterns.
-    - Can help compare functions between files during migrations or identify potential naming conflicts.
-
----
-*This workflow provides a general guideline. Adapt it based on your specific project needs and team practices.*
\ No newline at end of file
diff --git a/tmp_repo_contents/example_prd.txt b/tmp_repo_contents/example_prd.txt
deleted file mode 100644
index 194114d..0000000
--- a/tmp_repo_contents/example_prd.txt
+++ /dev/null
@@ -1,47 +0,0 @@
-<context>
-# Overview  
-[Provide a high-level overview of your product here. Explain what problem it solves, who it's for, and why it's valuable.]
-
-# Core Features  
-[List and describe the main features of your product. For each feature, include:
-- What it does
-- Why it's important
-- How it works at a high level]
-
-# User Experience  
-[Describe the user journey and experience. Include:
-- User personas
-- Key user flows
-- UI/UX considerations]
-</context>
-<PRD>
-# Technical Architecture  
-[Outline the technical implementation details:
-- System components
-- Data models
-- APIs and integrations
-- Infrastructure requirements]
-
-# Development Roadmap  
-[Break down the development process into phases:
-- MVP requirements
-- Future enhancements
-- Do not think about timelines whatsoever -- all that matters is scope and detailing exactly what needs to be build in each phase so it can later be cut up into tasks]
-
-# Logical Dependency Chain
-[Define the logical order of development:
-- Which features need to be built first (foundation)
-- Getting as quickly as possible to something usable/visible front end that works
-- Properly pacing and scoping each feature so it is atomic but can also be built upon and improved as development approaches]
-
-# Risks and Mitigations  
-[Identify potential risks and how they'll be addressed:
-- Technical challenges
-- Figuring out the MVP that we can build upon
-- Resource constraints]
-
-# Appendix  
-[Include any additional information:
-- Research findings
-- Technical specifications]
-</PRD>
\ No newline at end of file
diff --git a/tmp_repo_contents/hooks.py b/tmp_repo_contents/hooks.py
deleted file mode 100644
index 4cd4e2c..0000000
--- a/tmp_repo_contents/hooks.py
+++ /dev/null
@@ -1,11 +0,0 @@
-# modern_theme/hooks.py
-app_name = "modern_theme"
-app_title = "Modern Theme"
-app_publisher = "Modern Theme"
-app_description = "A modern, ClickUp-inspired theme for ERPNext."
-app_email = "info@example.com"
-app_license = "MIT"
-
-# Includes which assets to load for the desk
-app_include_css = "/assets/modern_theme/css/modern_theme.css"
-# app_include_js = "/assets/modern_theme/js/modern_theme.js" 
\ No newline at end of file
diff --git a/tmp_repo_contents/interactive-feedback-mcp b/tmp_repo_contents/interactive-feedback-mcp
deleted file mode 160000
index b3b9620..0000000
--- a/tmp_repo_contents/interactive-feedback-mcp
+++ /dev/null
@@ -1 +0,0 @@
-Subproject commit b3b9620608df27ae1515b5de89dd63189574e9b9
diff --git a/tmp_repo_contents/mcp.json b/tmp_repo_contents/mcp.json
deleted file mode 100644
index 5590afe..0000000
--- a/tmp_repo_contents/mcp.json
+++ /dev/null
@@ -1,19 +0,0 @@
-{
-	"mcpServers": {
-		"task-master-ai": {
-			"command": "npx",
-			"args": ["-y", "--package=task-master-ai", "task-master-ai"],
-			"env": {
-				"ANTHROPIC_API_KEY": "ANTHROPIC_API_KEY_HERE",
-				"PERPLEXITY_API_KEY": "PERPLEXITY_API_KEY_HERE",
-				"OPENAI_API_KEY": "OPENAI_API_KEY_HERE",
-				"GOOGLE_API_KEY": "GOOGLE_API_KEY_HERE",
-				"XAI_API_KEY": "XAI_API_KEY_HERE",
-				"OPENROUTER_API_KEY": "OPENROUTER_API_KEY_HERE",
-				"MISTRAL_API_KEY": "MISTRAL_API_KEY_HERE",
-				"AZURE_OPENAI_API_KEY": "AZURE_OPENAI_API_KEY_HERE",
-				"OLLAMA_API_KEY": "OLLAMA_API_KEY_HERE"
-			}
-		}
-	}
-}
diff --git a/tmp_repo_contents/modern_theme.css b/tmp_repo_contents/modern_theme.css
deleted file mode 100644
index 9089823..0000000
--- a/tmp_repo_contents/modern_theme.css
+++ /dev/null
@@ -1,321 +0,0 @@
-/* /modern_theme/public/css/modern_theme.css */
-
-/* Import a modern font like Inter */
-@import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
-
-:root {
-    /* Base Font */
-    --font-family-sans-serif: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto", "Oxygen", "Ubuntu", "Cantarell", "Fira Sans", "Droid Sans", "Helvetica Neue", sans-serif;
-
-    /* Primary ClickUp-inspired Colors */
-    --primary: #7b68ee; /* A nice medium purple/blue */
-    --primary-hover: #6a5acd;
-    --primary-light: #f0e6ff;
-
-    /* Neutral Grays */
-    --text-color: #495057;
-    --text-light: #6c757d;
-    --text-extra-light: #adb5bd;
-    --heading-color: #212529;
-    --border-color: #dee2e6;
-    --light-gray: #f8f9fa;
-    --very-light-gray: #fafbfc;
-
-    /* Backgrounds */
-    --page-bg: #f8f9fa;
-    --control-bg: #ffffff;
-    --modal-bg: #ffffff;
-    --sidebar-bg: #ffffff;
-
-    /* Status & Alerts */
-    --green: #28a745;
-    --red: #dc3545;
-    --yellow: #ffc107;
-    --blue: #007bff;
-
-    /* Other UI Elements */
-    --shadow: 0 1px 3px rgba(0, 0, 0, 0.05), 0 1px 2px rgba(0, 0, 0, 0.02);
-    --border-radius: 6px;
-}
-
-/* Apply the base font to the body */
-body {
-    font-family: var(--font-family-sans-serif) !important;
-}
-
-/* --- Sidebar Redesign --- */
-.standard-sidebar {
-    background-color: var(--sidebar-bg) !important;
-    border-right: 1px solid var(--border-color) !important;
-    box-shadow: var(--shadow) !important;
-    padding-top: 15px !important;
-}
-
-/* Sidebar item styling */
-.standard-sidebar .sidebar-section .sidebar-item {
-    padding: 10px 15px;
-    margin: 2px 0;
-    border-radius: var(--border-radius);
-    transition: background-color 0.2s, color 0.2s;
-}
-
-.standard-sidebar .sidebar-section .sidebar-item a {
-    color: var(--text-light);
-    font-weight: 500;
-}
-
-/* Hover state */
-.standard-sidebar .sidebar-section .sidebar-item:hover {
-    background-color: var(--light-gray);
-}
-
-.standard-sidebar .sidebar-section .sidebar-item:hover a {
-    color: var(--text-color);
-    text-decoration: none;
-}
-
-/* Active state */
-.standard-sidebar .sidebar-section .sidebar-item.active {
-    background-color: var(--primary-light);
-}
-
-.standard-sidebar .sidebar-section .sidebar-item.active a {
-    color: var(--primary);
-    font-weight: 600;
-}
-
-/* Icons */
-.standard-sidebar .sidebar-section .sidebar-item .indicator {
-    color: var(--primary);
-}
-
-/* --- Header Redesign --- */
-.page-head {
-    background-color: var(--control-bg) !important;
-    border-bottom: 1px solid var(--border-color) !important;
-    box-shadow: none !important;
-}
-
-/* Primary header button */
-.page-head .btn-primary {
-    background-color: var(--primary) !important;
-    border: none !important;
-    box-shadow: var(--shadow) !important;
-    transition: background-color 0.2s;
-}
-
-.page-head .btn-primary:hover {
-    background-color: var(--primary-hover) !important;
-}
-
-/* Search bar */
-.search-bar {
-    border-radius: var(--border-radius) !important;
-    background-color: var(--light-gray) !important;
-    border: 1px solid var(--border-color) !important;
-}
-
-.search-bar .form-control {
-    background-color: transparent !important;
-}
-
-/* User avatar / profile dropdown */
-.navbar-right .user-image {
-    border-radius: 50% !important;
-    border: 2px solid var(--primary-light);
-}
-
-.navbar-right .dropdown-toggle {
-    display: flex;
-    align-items: center;
-}
-
-/* --- Form Controls Redesign --- */
-
-/* Basic input and textarea styling */
-.form-control, .form-select {
-    border-radius: var(--border-radius) !important;
-    border: 1px solid var(--border-color) !important;
-    background-color: var(--control-bg) !important;
-    color: var(--text-color) !important;
-    padding: 8px 12px !important;
-    box-shadow: none !important;
-    transition: border-color 0.2s, box-shadow 0.2s;
-}
-
-.form-control:focus, .form-select:focus {
-    border-color: var(--primary) !important;
-    box-shadow: 0 0 0 2px var(--primary-light) !important;
-}
-
-/* Form buttons */
-.btn {
-    border-radius: var(--border-radius) !important;
-    font-weight: 500;
-    padding: 8px 16px;
-    box-shadow: var(--shadow) !important;
-    transition: filter 0.2s;
-}
-
-.btn:hover {
-    filter: brightness(95%);
-}
-
-.btn-primary {
-    background-color: var(--primary) !important;
-    border: none !important;
-}
-
-.btn-secondary, .btn-default {
-    background-color: var(--control-bg) !important;
-    border: 1px solid var(--border-color) !important;
-    color: var(--text-color) !important;
-}
-
-/* --- Form Layout & Page Structure --- */
-
-/* Main page container */
-.page-container {
-    background-color: var(--page-bg) !important;
-}
-
-/* Main form layout card */
-.form-layout {
-    background-color: var(--control-bg) !important;
-    border: 1px solid var(--border-color) !important;
-    border-radius: var(--border-radius) !important;
-    box-shadow: var(--shadow) !important;
-}
-
-/* Form section headers */
-.form-section {
-    border-bottom: 1px solid var(--border-color);
-    padding-bottom: 15px;
-    margin-bottom: 20px;
-}
-
-.section-head {
-    color: var(--heading-color);
-    font-size: 1.1rem;
-    font-weight: 600;
-    margin-bottom: 20px;
-}
-
-/* Spacing between form fields */
-.form-group {
-    margin-bottom: 1.25rem;
-}
-
-/* --- List View Redesign --- */
-
-/* Main list container */
-.list-container {
-    background-color: var(--control-bg) !important;
-    border: 1px solid var(--border-color) !important;
-    border-radius: var(--border-radius) !important;
-    box-shadow: var(--shadow) !important;
-}
-
-/* List headers */
-.list-row-head {
-    background-color: var(--light-gray) !important;
-    border-bottom: 2px solid var(--border-color) !important;
-}
-
-.list-row-head .list-col-heading {
-    color: var(--heading-color) !important;
-    font-weight: 600;
-    text-transform: uppercase;
-    font-size: 0.8rem;
-}
-
-/* List rows */
-.list-row {
-    border-bottom: 1px solid var(--border-color) !important;
-    transition: background-color 0.2s;
-}
-
-.list-row:hover {
-    background-color: var(--primary-light) !important;
-}
-
-.list-row a {
-    color: var(--text-color) !important;
-}
-
-/* --- Dashboard Redesign --- */
-
-/* Dashboard widget card */
-.widget {
-    background-color: var(--control-bg) !important;
-    border: 1px solid var(--border-color) !important;
-    border-radius: var(--border-radius) !important;
-    box-shadow: var(--shadow) !important;
-    padding: 20px !important;
-}
-
-.widget .widget-title {
-    font-size: 1rem;
-    font-weight: 600;
-    color: var(--heading-color);
-}
-
-/* Number cards */
-.widget .widget-numeric-value {
-    font-size: 2rem;
-    font-weight: 700;
-    color: var(--primary);
-}
-
-/* Chart styling */
-.frappe-chart .chart-axis-line,
-.frappe-chart .chart-axis-tick {
-    stroke: var(--border-color);
-}
-
-.frappe-chart .chart-label {
-    fill: var(--text-light);
-}
-
-.frappe-chart .bar .fill {
-    fill: var(--primary);
-}
-
-.frappe-chart .line .fill {
-    fill: var(--primary-light);
-}
-
-.frappe-chart .line .stroke {
-    stroke: var(--primary);
-}
-
-/* --- Global Components: Modals --- */
-
-.modal-content {
-    background-color: var(--modal-bg) !important;
-    border: 1px solid var(--border-color) !important;
-    border-radius: var(--border-radius) !important;
-    box-shadow: 0 5px 15px rgba(0,0,0,0.1) !important;
-}
-
-.modal-header {
-    background-color: var(--light-gray) !important;
-    border-bottom: 1px solid var(--border-color) !important;
-    padding: 15px 20px !important;
-}
-
-.modal-header .modal-title {
-    font-size: 1.2rem;
-    font-weight: 600;
-    color: var(--heading-color);
-}
-
-.modal-body {
-    padding: 20px !important;
-}
-
-.modal-footer {
-    background-color: var(--light-gray) !important;
-    border-top: 1px solid var(--border-color) !important;
-    padding: 15px 20px !important;
-} 
\ No newline at end of file
diff --git a/tmp_repo_contents/modules.txt b/tmp_repo_contents/modules.txt
deleted file mode 100644
index 3fe5f9c..0000000
--- a/tmp_repo_contents/modules.txt
+++ /dev/null
@@ -1 +0,0 @@
-Modern Theme 
\ No newline at end of file
diff --git a/tmp_repo_contents/orchestrator-rules b/tmp_repo_contents/orchestrator-rules
deleted file mode 100644
index 96d1c2e..0000000
--- a/tmp_repo_contents/orchestrator-rules
+++ /dev/null
@@ -1,181 +0,0 @@
-**Core Directives & Agentivity:**
-# 1. Adhere strictly to the rules defined below.
-# 2. Use tools sequentially, one per message. Adhere strictly to the rules defined below.
-# 3. CRITICAL: ALWAYS wait for user confirmation of success after EACH tool use before proceeding. Do not assume success.
-# 4. Operate iteratively: Analyze task -> Plan steps -> Execute steps one by one.
-# 5. Use <thinking> tags for *internal* analysis before tool use (context, tool choice, required params).
-# 6. **DO NOT DISPLAY XML TOOL TAGS IN THE OUTPUT.**
-# 7. **DO NOT DISPLAY YOUR THINKING IN THE OUTPUT.**
-
-**Workflow Orchestration Role:**
-
-Your role is to coordinate complex workflows by delegating tasks to specialized modes, using `taskmaster-ai` as the central hub for task definition, progress tracking, and context management. As an orchestrator, you should always delegate tasks:
-
-1.  **Task Decomposition:** When given a complex task, analyze it and break it down into logical subtasks suitable for delegation. If TASKMASTER IS ON Leverage `taskmaster-ai` (`get_tasks`, `analyze_project_complexity`, `expand_task`) to understand the existing task structure and identify areas needing updates and/or breakdown.
-2.  **Delegation via `new_task`:** For each subtask identified (or if creating new top-level tasks via `add_task` is needed first), use the `new_task` tool to delegate.
-    *   Choose the most appropriate mode for the subtask's specific goal.
-    *   Provide comprehensive instructions in the `message` parameter, including:
-        *   All necessary context from the parent task (retrieved via `get_task` or `get_tasks` from `taskmaster-ai`) or previous subtasks.
-        *   A clearly defined scope, specifying exactly what the subtask should accomplish. Reference the relevant `taskmaster-ai` task/subtask ID.
-        *   An explicit statement that the subtask should *only* perform the work outlined and not deviate.
-        *   An instruction for the subtask to signal completion using `attempt_completion`, providing a concise yet thorough summary of the outcome in the `result` parameter. This summary is crucial for updating `taskmaster-ai`.
-        *   A statement that these specific instructions supersede any conflicting general instructions the subtask's mode might have.
-3.  **Progress Tracking & Context Management (using `taskmaster-ai`):**
-    *   Track and manage the progress of all subtasks primarily through `taskmaster-ai`.
-    *   When a subtask completes (signaled via `attempt_completion`), **process its `result` directly**. Update the relevant task/subtask status and details in `taskmaster-ai` using `set_task_status`, `update_task`, or `update_subtask`. Handle failures explicitly (see Result Reception below).
-    *   After processing the result and updating Taskmaster, determine the next steps based on the updated task statuses and dependencies managed by `taskmaster-ai` (use `next_task`). This might involve delegating the next task, asking the user for clarification (`ask_followup_question`), or proceeding to synthesis.
-    *   Use `taskmaster-ai`'s `set_task_status` tool when starting to work on a new task to mark tasks/subtasks as 'in-progress'. If a subtask reports back with a 'review' status via `attempt_completion`, update Taskmaster accordingly, and then decide the next step: delegate to Architect/Test/Debug for specific review, or use `ask_followup_question` to consult the user directly.
-4.  **User Communication:** Help the user understand the workflow, the status of tasks (using info from `get_tasks` or `get_task`), and how subtasks fit together. Provide clear reasoning for delegation choices.
-5.  **Synthesis:** When all relevant tasks managed by `taskmaster-ai` for the user's request are 'done' (confirm via `get_tasks`), **perform the final synthesis yourself**. Compile the summary based on the information gathered and logged in Taskmaster throughout the workflow and present it using `attempt_completion`.
-6.  **Clarification:** Ask clarifying questions (using `ask_followup_question`) when necessary to better understand how to break down or manage tasks within `taskmaster-ai`.
-
-Use subtasks (`new_task`) to maintain clarity. If a request significantly shifts focus or requires different expertise, create a subtask.
-
-**Taskmaster-AI Strategy:**
-
-taskmaster_strategy:
-  status_prefix: "Begin EVERY response with either '[TASKMASTER: ON]' or '[TASKMASTER: OFF]', indicating if the Task Master project structure (e.g., `tasks/tasks.json`) appears to be set up."
-  initialization: |
-      <thinking>
-      - **CHECK FOR TASKMASTER:**
-      - Plan: Use `list_files` to check if `tasks/tasks.json` is PRESENT in the project root, then TASKMASTER has been initialized.
-      - if `tasks/tasks.json` is present = set TASKMASTER: ON, else TASKMASTER: OFF
-      </thinking>
-      *Execute the plan described above.*
-  if_uninitialized: |
-      1. **Inform & Suggest:**
-         "It seems Task Master hasn't been initialized in this project yet. TASKMASTER helps manage tasks and context effectively. Would you like me to delegate to the code mode to run the `initialize_project` command for TASKMASTER?"
-      2. **Conditional Actions:**
-         * If the user declines:
-           <thinking>
-           I need to proceed without TASKMASTER functionality. I will inform the user and set the status accordingly.
-           </thinking>
-           a. Inform the user: "Ok, I will proceed without initializing TASKMASTER."
-           b. Set status to '[TASKMASTER: OFF]'.
-           c. Attempt to handle the user's request directly if possible.
-         * If the user agrees:
-           <thinking>
-           I will use `new_task` to delegate project initialization to the `code` mode using the `taskmaster-ai` `initialize_project` tool. I need to ensure the `projectRoot` argument is correctly set.
-           </thinking>
-           a. Use `new_task` with `mode: code`` and instructions to execute the `taskmaster-ai` `initialize_project` tool via `use_mcp_tool`. Provide necessary details like `projectRoot`. Instruct Code mode to report completion via `attempt_completion`.
-  if_ready: |
-      <thinking>
-      Plan: Use `use_mcp_tool` with `server_name: taskmaster-ai`, `tool_name: get_tasks`, and required arguments (`projectRoot`). This verifies connectivity and loads initial task context.
-      </thinking>
-      1. **Verify & Load:** Attempt to fetch tasks using `taskmaster-ai`'s `get_tasks` tool.
-      2. **Set Status:** Set status to '[TASKMASTER: ON]'.
-      3. **Inform User:** "TASKMASTER is ready. I have loaded the current task list."
-      4. **Proceed:** Proceed with the user's request, utilizing `taskmaster-ai` tools for task management and context as described in the 'Workflow Orchestration Role'.
-
-**Mode Collaboration & Triggers:**
-
-mode_collaboration: |
-    # Collaboration definitions for how Orchestrator orchestrates and interacts.
-    # Orchestrator delegates via `new_task` using taskmaster-ai for task context,
-    # receives results via `attempt_completion`, processes them, updates taskmaster-ai, and determines the next step.
-
-      1. Architect Mode Collaboration: # Interaction initiated BY Orchestrator
-        - Delegation via `new_task`:
-          * Provide clear architectural task scope (referencing taskmaster-ai task ID).
-          * Request design, structure, planning based on taskmaster context.
-        - Completion Reporting TO Orchestrator: # Receiving results FROM Architect via attempt_completion
-          * Expect design decisions, artifacts created, completion status (taskmaster-ai task ID).
-          * Expect context needed for subsequent implementation delegation.
-
-    2. Test Mode Collaboration: # Interaction initiated BY Orchestrator
-      - Delegation via `new_task`:
-        * Provide clear testing scope (referencing taskmaster-ai task ID).
-        * Request test plan development, execution, verification based on taskmaster context.
-      - Completion Reporting TO Orchestrator: # Receiving results FROM Test via attempt_completion
-        * Expect summary of test results (pass/fail, coverage), completion status (taskmaster-ai task ID).
-        * Expect details on bugs or validation issues.
-
-    3. Debug Mode Collaboration: # Interaction initiated BY Orchestrator
-      - Delegation via `new_task`:
-        * Provide clear debugging scope (referencing taskmaster-ai task ID).
-        * Request investigation, root cause analysis based on taskmaster context.
-      - Completion Reporting TO Orchestrator: # Receiving results FROM Debug via attempt_completion
-        * Expect summary of findings (root cause, affected areas), completion status (taskmaster-ai task ID).
-        * Expect recommended fixes or next diagnostic steps.
-
-    4. Ask Mode Collaboration: # Interaction initiated BY Orchestrator
-      - Delegation via `new_task`:
-        * Provide clear question/analysis request (referencing taskmaster-ai task ID).
-        * Request research, context analysis, explanation based on taskmaster context.
-      - Completion Reporting TO Orchestrator: # Receiving results FROM Ask via attempt_completion
-        * Expect answers, explanations, analysis results, completion status (taskmaster-ai task ID).
-        * Expect cited sources or relevant context found.
-
-    5. Code Mode Collaboration: # Interaction initiated BY Orchestrator
-      - Delegation via `new_task`:
-        * Provide clear coding requirements (referencing taskmaster-ai task ID).
-        * Request implementation, fixes, documentation, command execution based on taskmaster context.
-      - Completion Reporting TO Orchestrator: # Receiving results FROM Code via attempt_completion
-        * Expect outcome of commands/tool usage, summary of code changes/operations, completion status (taskmaster-ai task ID).
-        * Expect links to commits or relevant code sections if relevant.
-
-    7. Orchestrator Mode Collaboration: # Orchestrator's Internal Orchestration Logic
-      # Orchestrator orchestrates via delegation, using taskmaster-ai as the source of truth.
-      - Task Decomposition & Planning:
-        * Analyze complex user requests, potentially delegating initial analysis to Architect mode.
-        * Use `taskmaster-ai` (`get_tasks`, `analyze_project_complexity`) to understand current state.
-        * Break down into logical, delegate-able subtasks (potentially creating new tasks/subtasks in `taskmaster-ai` via `add_task`, `expand_task` delegated to Code mode if needed).
-        * Identify appropriate specialized mode for each subtask.
-      - Delegation via `new_task`:
-        * Formulate clear instructions referencing `taskmaster-ai` task IDs and context.
-        * Use `new_task` tool to assign subtasks to chosen modes.
-        * Track initiated subtasks (implicitly via `taskmaster-ai` status, e.g., setting to 'in-progress').
-      - Result Reception & Processing:
-        * Receive completion reports (`attempt_completion` results) from subtasks.
-        * **Process the result:** Analyze success/failure and content.
-        * **Update Taskmaster:** Use `set_task_status`, `update_task`, or `update_subtask` to reflect the outcome (e.g., 'done', 'failed', 'review') and log key details/context from the result.
-        * **Handle Failures:** If a subtask fails, update status to 'failed', log error details using `update_task`/`update_subtask`, inform the user, and decide next step (e.g., delegate to Debug, ask user).
-        * **Handle Review Status:** If status is 'review', update Taskmaster, then decide whether to delegate further review (Architect/Test/Debug) or consult the user (`ask_followup_question`).
-      - Workflow Management & User Interaction:
-        * **Determine Next Step:** After processing results and updating Taskmaster, use `taskmaster-ai` (`next_task`) to identify the next task based on dependencies and status.
-        * Communicate workflow plan and progress (based on `taskmaster-ai` data) to the user.
-        * Ask clarifying questions if needed for decomposition/delegation (`ask_followup_question`).
-      - Synthesis:
-        * When `get_tasks` confirms all relevant tasks are 'done', compile the final summary from Taskmaster data.
-        * Present the overall result using `attempt_completion`.
-
-mode_triggers:
-  # Conditions that trigger a switch TO the specified mode via switch_mode.
-  # Note: Orchestrator mode is typically initiated for complex tasks or explicitly chosen by the user,
-  #       and receives results via attempt_completion, not standard switch_mode triggers from other modes.
-  # These triggers remain the same as they define inter-mode handoffs, not Orchestrator's internal logic.
-
-  architect:
-    - condition: needs_architectural_changes
-    - condition: needs_further_scoping
-    - condition: needs_analyze_complexity
-    - condition: design_clarification_needed
-    - condition: pattern_violation_found
-  test:
-    - condition: tests_need_update
-    - condition: coverage_check_needed
-    - condition: feature_ready_for_testing
-  debug:
-    - condition: error_investigation_needed
-    - condition: performance_issue_found
-    - condition: system_analysis_required
-  ask:
-    - condition: documentation_needed
-    - condition: implementation_explanation
-    - condition: pattern_documentation
-  code:
-    - condition: global_mode_access
-    - condition: mode_independent_actions
-    - condition: system_wide_commands
-    - condition: implementation_needed       # From Architect
-    - condition: code_modification_needed    # From Architect
-    - condition: refactoring_required        # From Architect
-    - condition: test_fixes_required         # From Test
-    - condition: coverage_gaps_found         # From Test (Implies coding needed)
-    - condition: validation_failed           # From Test (Implies coding needed)
-    - condition: fix_implementation_ready    # From Debug
-    - condition: performance_fix_needed      # From Debug
-    - condition: error_pattern_found         # From Debug (Implies preventative coding)
-    - condition: clarification_received      # From Ask (Allows coding to proceed)
-    - condition: code_task_identified        # From code
-    - condition: mcp_result_needs_coding     # From code
\ No newline at end of file
diff --git a/tmp_repo_contents/prd.md b/tmp_repo_contents/prd.md
deleted file mode 100644
index 221c032..0000000
--- a/tmp_repo_contents/prd.md
+++ /dev/null
@@ -1,72 +0,0 @@
-## Product Requirements Document: ERPNext Modern UI (ClickUp Inspired)
-
-### 1. Introduction
-
-This document outlines the requirements for a new custom theme for ERPNext, designed to modernize its user interface (UI) and user experience (UX). The new theme will be delivered as a custom Frappe application, ensuring it is easy to install, maintain, and update without modifying the core ERPNext codebase. The primary design inspiration for this project is the UI of **ClickUp**, a project management tool known for its clean, modern, and intuitive interface.
-
-### 2. Vision and Goal
-
-Our vision is to transform the ERPNext user experience from a traditional, data-heavy interface into a modern, visually appealing, and intuitive workspace. We want to make ERPNext not only powerful but also enjoyable to use.
-
-The primary goal of this project is to **increase user adoption and satisfaction** by providing a UI that is:
-
-*   **Modern and Aesthetically Pleasing:** Replace the dated look and feel with a fresh, clean design.
-*   **Intuitive and User-Friendly:** Improve navigation and information hierarchy to reduce the learning curve for new users.
-*   **Non-disruptive:** Enhance the UI without altering the core functionality or workflows that users rely on.
-
-### 3. Problem Statement
-
-The default ERPNext UI, while functional, is often perceived as:
-
-*   **Outdated:** The design does not align with modern web application standards, which can make it feel clunky and unintuitive.
-*   **Overwhelming for New Users:** The dense information layout and traditional ERP design can be intimidating for users unfamiliar with such systems.
-*   **Lacking in Visual Polish:** The aesthetics do not inspire user engagement, which can impact overall productivity and satisfaction.
-
-This project aims to solve these problems by delivering a beautiful, modern, and easy-to-navigate UI theme inspired by ClickUp.
-
-### 4. Scope and Features
-
-This project is focused exclusively on the UI/UX of the ERPNext Desk. Core backend functionality will not be changed.
-
-#### In Scope:
-
-*   **New Color Palette:** Implement a modern and clean color scheme inspired by ClickUp, with a focus on blues, grays, and whites for a professional look.
-*   **Modern Typography:** Update the default fonts to a more modern and readable alternative, such as Inter or a similar sans-serif font.
-*   **Redesigned Navigation:**
-    *   **Sidebar:** Overhaul the main sidebar to be cleaner, with better-organized modules and icons.
-    *   **Header:** Redesign the header for a more streamlined look.
-*   **Updated Form and List Views:**
-    *   **Forms:** Redesign form layouts to be cleaner, with better spacing and more modern input fields, buttons, and other controls.
-    *   **Lists:** Improve the list view with better row spacing, clearer action buttons, and a more modern aesthetic.
-*   **Dashboard Enhancements:** Restyle the dashboard widgets for a more modern and visually engaging look.
-*   **Custom App Delivery:** All changes will be packaged into a single, installable custom Frappe app.
-
-#### Out of Scope:
-
-*   **Changes to Core Functionality:** We will not alter any of the business logic or workflows of ERPNext.
-*   **Website Theme:** This project will not affect the public-facing website theme.
-*   **New Features:** We will not be adding any new features to ERPNext (e.g., a new type of report or a new module).
-*   **Mobile App UI:** The scope is limited to the web-based Desk UI.
-
-### 5. Design and UX Requirements
-
-*   **Inspiration:** The primary design reference is **ClickUp**. We should aim to capture its clean, spacious, and intuitive feel.
-*   **Colors:** The theme will use a primary color (e.g., a modern blue) for actions and navigation, with a neutral palette (light grays and whites) for the background and other elements.
-*   **Spacing:** Increase whitespace and padding to reduce visual clutter and improve readability.
-*   **Icons:** Utilize a consistent and modern icon set, possibly from a library like Feather Icons or a similar alternative.
-*   **Responsiveness:** The new theme must be fully responsive and work seamlessly on all major browsers (Chrome, Firefox, Safari) and screen sizes.
-
-### 6. Technical Requirements
-
-*   **Custom Frappe App:** The theme will be developed as a standalone custom app to ensure it doesn't interfere with core ERPNext updates.
-*   **CSS Overrides:** The primary method for styling will be through custom CSS that overrides the default Frappe/ERPNext styles.
-*   **JavaScript for Dynamic Changes:** If needed, JavaScript will be used for minor DOM manipulations or to enhance UI interactions.
-*   **Hooks:** The app will use `hooks.py` to inject the necessary CSS and JavaScript files into the ERPNext Desk.
-
-### 7. Success Metrics
-
-The success of this project will be measured by:
-
-*   **User Feedback:** Positive feedback from users on the new design. This can be collected through surveys or informal feedback channels.
-*   **Adoption Rate:** The number of users who choose to use the new theme (if it's made optional alongside the default).
-*   **Reduced Training Time:** Anecdotal evidence from team leads or trainers that new users are finding the system easier to navigate. 
\ No newline at end of file
diff --git a/tmp_repo_contents/pyproject.toml b/tmp_repo_contents/pyproject.toml
deleted file mode 100644
index 0d3b4a8..0000000
--- a/tmp_repo_contents/pyproject.toml
+++ /dev/null
@@ -1,15 +0,0 @@
-[build-system]
-requires = ["flit_core<4,>=3"]
-build-backend = "flit_core.buildapi"
-
-[project]
-name = "modern_theme"
-authors = [{ name = "Modern Theme", email = "info@example.com" }]
-dynamic = ["version", "description"]
-dependencies = []
-readme = "README.md"
-license = { file = "LICENSE" }
-classifiers = ["Private :: Do Not Upload"]
-
-[project.urls]
-Source = "https://github.com/user/modern_theme" 
\ No newline at end of file
diff --git a/tmp_repo_contents/roo_rules.md b/tmp_repo_contents/roo_rules.md
deleted file mode 100644
index 685c895..0000000
--- a/tmp_repo_contents/roo_rules.md
+++ /dev/null
@@ -1,53 +0,0 @@
----
-description: Guidelines for creating and maintaining Roo Code rules to ensure consistency and effectiveness.
-globs: .roo/rules/*.md
-alwaysApply: true
----
-
-- **Required Rule Structure:**
-  ```markdown
-  ---
-  description: Clear, one-line description of what the rule enforces
-  globs: path/to/files/*.ext, other/path/**/*
-  alwaysApply: boolean
-  ---
-
-  - **Main Points in Bold**
-    - Sub-points with details
-    - Examples and explanations
-  ```
-
-- **File References:**
-  - Use `[filename](mdc:path/to/file)` ([filename](mdc:filename)) to reference files
-  - Example: [prisma.md](.roo/rules/prisma.md) for rule references
-  - Example: [schema.prisma](mdc:prisma/schema.prisma) for code references
-
-- **Code Examples:**
-  - Use language-specific code blocks
-  ```typescript
-  // ✅ DO: Show good examples
-  const goodExample = true;
-  
-  // ❌ DON'T: Show anti-patterns
-  const badExample = false;
-  ```
-
-- **Rule Content Guidelines:**
-  - Start with high-level overview
-  - Include specific, actionable requirements
-  - Show examples of correct implementation
-  - Reference existing code when possible
-  - Keep rules DRY by referencing other rules
-
-- **Rule Maintenance:**
-  - Update rules when new patterns emerge
-  - Add examples from actual codebase
-  - Remove outdated patterns
-  - Cross-reference related rules
-
-- **Best Practices:**
-  - Use bullet points for clarity
-  - Keep descriptions concise
-  - Include both DO and DON'T examples
-  - Reference actual code over theoretical examples
-  - Use consistent formatting across rules 
\ No newline at end of file
diff --git a/tmp_repo_contents/self_improve.md b/tmp_repo_contents/self_improve.md
deleted file mode 100644
index 88abc6e..0000000
--- a/tmp_repo_contents/self_improve.md
+++ /dev/null
@@ -1,72 +0,0 @@
----
-description: Guidelines for continuously improving Windsurf rules based on emerging code patterns and best practices.
-globs: **/*
-alwaysApply: true
----
-
-- **Rule Improvement Triggers:**
-  - New code patterns not covered by existing rules
-  - Repeated similar implementations across files
-  - Common error patterns that could be prevented
-  - New libraries or tools being used consistently
-  - Emerging best practices in the codebase
-
-- **Analysis Process:**
-  - Compare new code with existing rules
-  - Identify patterns that should be standardized
-  - Look for references to external documentation
-  - Check for consistent error handling patterns
-  - Monitor test patterns and coverage
-
-- **Rule Updates:**
-  - **Add New Rules When:**
-    - A new technology/pattern is used in 3+ files
-    - Common bugs could be prevented by a rule
-    - Code reviews repeatedly mention the same feedback
-    - New security or performance patterns emerge
-
-  - **Modify Existing Rules When:**
-    - Better examples exist in the codebase
-    - Additional edge cases are discovered
-    - Related rules have been updated
-    - Implementation details have changed
-
-- **Example Pattern Recognition:**
-  ```typescript
-  // If you see repeated patterns like:
-  const data = await prisma.user.findMany({
-    select: { id: true, email: true },
-    where: { status: 'ACTIVE' }
-  });
-  
-  // Consider adding to [prisma.md](.windsurf/rules/prisma.md):
-  // - Standard select fields
-  // - Common where conditions
-  // - Performance optimization patterns
-  ```
-
-- **Rule Quality Checks:**
-  - Rules should be actionable and specific
-  - Examples should come from actual code
-  - References should be up to date
-  - Patterns should be consistently enforced
-
-- **Continuous Improvement:**
-  - Monitor code review comments
-  - Track common development questions
-  - Update rules after major refactors
-  - Add links to relevant documentation
-  - Cross-reference related rules
-
-- **Rule Deprecation:**
-  - Mark outdated patterns as deprecated
-  - Remove rules that no longer apply
-  - Update references to deprecated rules
-  - Document migration paths for old patterns
-
-- **Documentation Updates:**
-  - Keep examples synchronized with code
-  - Update references to external docs
-  - Maintain links between related rules
-  - Document breaking changes
-Follow [windsurf_rules.md](.windsurf/rules/windsurf_rules.md) for proper rule formatting and structure.
diff --git a/tmp_repo_contents/self_improve.mdc b/tmp_repo_contents/self_improve.mdc
deleted file mode 100644
index 40b31b6..0000000
--- a/tmp_repo_contents/self_improve.mdc
+++ /dev/null
@@ -1,72 +0,0 @@
----
-description: Guidelines for continuously improving Cursor rules based on emerging code patterns and best practices.
-globs: **/*
-alwaysApply: true
----
-
-- **Rule Improvement Triggers:**
-  - New code patterns not covered by existing rules
-  - Repeated similar implementations across files
-  - Common error patterns that could be prevented
-  - New libraries or tools being used consistently
-  - Emerging best practices in the codebase
-
-- **Analysis Process:**
-  - Compare new code with existing rules
-  - Identify patterns that should be standardized
-  - Look for references to external documentation
-  - Check for consistent error handling patterns
-  - Monitor test patterns and coverage
-
-- **Rule Updates:**
-  - **Add New Rules When:**
-    - A new technology/pattern is used in 3+ files
-    - Common bugs could be prevented by a rule
-    - Code reviews repeatedly mention the same feedback
-    - New security or performance patterns emerge
-
-  - **Modify Existing Rules When:**
-    - Better examples exist in the codebase
-    - Additional edge cases are discovered
-    - Related rules have been updated
-    - Implementation details have changed
-
-- **Example Pattern Recognition:**
-  ```typescript
-  // If you see repeated patterns like:
-  const data = await prisma.user.findMany({
-    select: { id: true, email: true },
-    where: { status: 'ACTIVE' }
-  });
-  
-  // Consider adding to [prisma.mdc](mdc:.cursor/rules/prisma.mdc):
-  // - Standard select fields
-  // - Common where conditions
-  // - Performance optimization patterns
-  ```
-
-- **Rule Quality Checks:**
-  - Rules should be actionable and specific
-  - Examples should come from actual code
-  - References should be up to date
-  - Patterns should be consistently enforced
-
-- **Continuous Improvement:**
-  - Monitor code review comments
-  - Track common development questions
-  - Update rules after major refactors
-  - Add links to relevant documentation
-  - Cross-reference related rules
-
-- **Rule Deprecation:**
-  - Mark outdated patterns as deprecated
-  - Remove rules that no longer apply
-  - Update references to deprecated rules
-  - Document migration paths for old patterns
-
-- **Documentation Updates:**
-  - Keep examples synchronized with code
-  - Update references to external docs
-  - Maintain links between related rules
-  - Document breaking changes
-Follow [cursor_rules.mdc](mdc:.cursor/rules/cursor_rules.mdc) for proper rule formatting and structure.
diff --git a/tmp_repo_contents/state.json b/tmp_repo_contents/state.json
deleted file mode 100644
index ec85722..0000000
--- a/tmp_repo_contents/state.json
+++ /dev/null
@@ -1,6 +0,0 @@
-{
-  "currentTag": "master",
-  "lastSwitched": "2025-06-25T08:08:56.303Z",
-  "branchTagMapping": {},
-  "migrationNoticeShown": false
-}
\ No newline at end of file
diff --git a/tmp_repo_contents/task-complexity-report.json b/tmp_repo_contents/task-complexity-report.json
deleted file mode 100644
index 09a9e3d..0000000
--- a/tmp_repo_contents/task-complexity-report.json
+++ /dev/null
@@ -1,93 +0,0 @@
-{
-	"meta": {
-		"generatedAt": "2025-06-25T08:12:30.214Z",
-		"tasksAnalyzed": 10,
-		"totalTasks": 10,
-		"analysisCount": 10,
-		"thresholdScore": 7,
-		"projectName": "Task Master",
-		"usedResearch": false
-	},
-	"complexityAnalysis": [
-		{
-			"taskId": 1,
-			"taskTitle": "Setup Custom Frappe App Structure",
-			"complexityScore": 3,
-			"recommendedSubtasks": 3,
-			"expansionPrompt": "Break down the 'Setup Custom Frappe App Structure' task into subtasks covering: 1) Initial app creation and directory setup, 2) Configuration of metadata and hooks, and 3) Documentation and version control setup.",
-			"reasoning": "This is a relatively straightforward task for someone familiar with Frappe. It involves standard app creation commands and basic file structure setup. The steps are well-defined and sequential with clear success criteria."
-		},
-		{
-			"taskId": 2,
-			"taskTitle": "Define Modern Color Palette and Typography",
-			"complexityScore": 5,
-			"recommendedSubtasks": 4,
-			"expansionPrompt": "Break down the 'Define Modern Color Palette and Typography' task into subtasks covering: 1) Research and color palette definition, 2) Typography selection and implementation, 3) CSS variables and utility classes creation, and 4) Style guide documentation.",
-			"reasoning": "This task requires design decisions and technical implementation. It involves research, creative work, and technical CSS implementation. The complexity comes from needing to create a cohesive design system that will serve as the foundation for the entire UI overhaul."
-		},
-		{
-			"taskId": 3,
-			"taskTitle": "Redesign Main Navigation Sidebar",
-			"complexityScore": 6,
-			"recommendedSubtasks": 4,
-			"expansionPrompt": "Break down the 'Redesign Main Navigation Sidebar' task into subtasks covering: 1) CSS styling for sidebar structure and layout, 2) Icon and typography implementation, 3) Interactive elements and state styling, and 4) JavaScript enhancements for improved functionality.",
-			"reasoning": "This task involves modifying core UI elements of ERPNext which requires understanding the existing DOM structure. It combines both CSS styling and potential JavaScript modifications to enhance functionality. Testing across different states (collapsed/expanded) adds complexity."
-		},
-		{
-			"taskId": 4,
-			"taskTitle": "Redesign Header and Global Navigation",
-			"complexityScore": 6,
-			"recommendedSubtasks": 4,
-			"expansionPrompt": "Break down the 'Redesign Header and Global Navigation' task into subtasks covering: 1) Header layout and structure styling, 2) Navigation elements and search bar redesign, 3) Dropdown and interactive elements styling, and 4) Responsive behavior implementation.",
-			"reasoning": "Similar to the sidebar task, this involves modifying core UI elements with both CSS and JavaScript. The header contains multiple interactive elements (search, notifications, user menu) that need to maintain functionality while being restyled."
-		},
-		{
-			"taskId": 5,
-			"taskTitle": "Modernize Form Views",
-			"complexityScore": 8,
-			"recommendedSubtasks": 6,
-			"expansionPrompt": "Break down the 'Modernize Form Views' task into subtasks covering: 1) Basic input field styling, 2) Button and action element redesign, 3) Form layout and section styling, 4) Custom form controls (checkboxes, dropdowns, etc.), 5) Form validation and error states, and 6) Accessibility improvements.",
-			"reasoning": "Forms are complex UI elements with many different input types, states, and behaviors. This task requires comprehensive styling of numerous form elements while ensuring they remain functional. Accessibility considerations and validation states add significant complexity."
-		},
-		{
-			"taskId": 6,
-			"taskTitle": "Enhance List Views",
-			"complexityScore": 7,
-			"recommendedSubtasks": 5,
-			"expansionPrompt": "Break down the 'Enhance List Views' task into subtasks covering: 1) List row and header styling, 2) Action buttons and menu redesign, 3) Filter and search element styling, 4) Pagination and bulk action controls, and 5) Responsive behavior for different screen sizes.",
-			"reasoning": "List views contain multiple interactive elements and need to handle varying amounts of data. The task involves styling rows, headers, action buttons, filters, and ensuring proper responsive behavior. The complexity comes from maintaining functionality while improving the visual design."
-		},
-		{
-			"taskId": 7,
-			"taskTitle": "Redesign Dashboard Widgets",
-			"complexityScore": 7,
-			"recommendedSubtasks": 5,
-			"expansionPrompt": "Break down the 'Redesign Dashboard Widgets' task into subtasks covering: 1) Widget card styling and layout, 2) Chart and data visualization enhancements, 3) Dashboard controls and filters redesign, 4) Widget-specific styling (numbers, lists, charts), and 5) Responsive layout implementation.",
-			"reasoning": "Dashboard widgets involve data visualization components which are more complex to style than standard UI elements. Different widget types (charts, numbers, lists) require specific styling approaches. Ensuring responsive behavior for dashboards adds another layer of complexity."
-		},
-		{
-			"taskId": 8,
-			"taskTitle": "Implement Global UI Enhancements",
-			"complexityScore": 8,
-			"recommendedSubtasks": 6,
-			"expansionPrompt": "Break down the 'Implement Global UI Enhancements' task into subtasks covering: 1) Modal and dialog styling, 2) Tooltip and popover redesign, 3) Notification and alert styling, 4) Tab and accordion components, 5) Data tables and grid components, and 6) Loading states and empty state designs.",
-			"reasoning": "This task covers a wide range of UI components that appear throughout the application. Each component type has its own complexity and interaction patterns. Ensuring consistency across all these elements while maintaining functionality requires significant effort and attention to detail."
-		},
-		{
-			"taskId": 9,
-			"taskTitle": "Implement Responsive Design Optimizations",
-			"complexityScore": 8,
-			"recommendedSubtasks": 5,
-			"expansionPrompt": "Break down the 'Implement Responsive Design Optimizations' task into subtasks covering: 1) Desktop to tablet breakpoint optimizations, 2) Tablet to mobile breakpoint optimizations, 3) Touch interface enhancements, 4) Browser compatibility testing and fixes, and 5) Responsive typography and spacing system.",
-			"reasoning": "Responsive design requires testing and optimization across multiple device sizes and browsers. This task involves addressing layout issues, touch interactions, and ensuring the application remains usable on small screens. Cross-browser testing adds significant complexity."
-		},
-		{
-			"taskId": 10,
-			"taskTitle": "Create Documentation and Finalize Package",
-			"complexityScore": 5,
-			"recommendedSubtasks": 4,
-			"expansionPrompt": "Break down the 'Create Documentation and Finalize Package' task into subtasks covering: 1) User and installation documentation, 2) Code optimization and asset minification, 3) Theme configuration options and settings page, and 4) Release preparation and distribution.",
-			"reasoning": "This task involves documentation, optimization, and packaging the application for distribution. While not as technically complex as some other tasks, it requires thoroughness to ensure the package is complete, well-documented, and ready for users to install and configure."
-		}
-	]
-}
\ No newline at end of file
diff --git a/tmp_repo_contents/taskmaster.md b/tmp_repo_contents/taskmaster.md
deleted file mode 100644
index 533f3f6..0000000
--- a/tmp_repo_contents/taskmaster.md
+++ /dev/null
@@ -1,558 +0,0 @@
----
-description: Comprehensive reference for Taskmaster MCP tools and CLI commands.
-globs: **/*
-alwaysApply: true
----
-
-# Taskmaster Tool & Command Reference
-
-This document provides a detailed reference for interacting with Taskmaster, covering both the recommended MCP tools, suitable for integrations like Windsurf, and the corresponding `task-master` CLI commands, designed for direct user interaction or fallback.
-
-**Note:** For interacting with Taskmaster programmatically or via integrated tools, using the **MCP tools is strongly recommended** due to better performance, structured data, and error handling. The CLI commands serve as a user-friendly alternative and fallback. 
-
-**Important:** Several MCP tools involve AI processing... The AI-powered tools include `parse_prd`, `analyze_project_complexity`, `update_subtask`, `update_task`, `update`, `expand_all`, `expand_task`, and `add_task`.
-
-**🏷️ Tagged Task Lists System:** Task Master now supports **tagged task lists** for multi-context task management. This allows you to maintain separate, isolated lists of tasks for different features, branches, or experiments. Existing projects are seamlessly migrated to use a default "master" tag. Most commands now support a `--tag <name>` flag to specify which context to operate on. If omitted, commands use the currently active tag.
-
----
-
-## Initialization & Setup
-
-### 1. Initialize Project (`init`)
-
-*   **MCP Tool:** `initialize_project`
-*   **CLI Command:** `task-master init [options]`
-*   **Description:** `Set up the basic Taskmaster file structure and configuration in the current directory for a new project.`
-*   **Key CLI Options:**
-    *   `--name <name>`: `Set the name for your project in Taskmaster's configuration.`
-    *   `--description <text>`: `Provide a brief description for your project.`
-    *   `--version <version>`: `Set the initial version for your project, e.g., '0.1.0'.`
-    *   `-y, --yes`: `Initialize Taskmaster quickly using default settings without interactive prompts.`
-*   **Usage:** Run this once at the beginning of a new project.
-*   **MCP Variant Description:** `Set up the basic Taskmaster file structure and configuration in the current directory for a new project by running the 'task-master init' command.`
-*   **Key MCP Parameters/Options:**
-    *   `projectName`: `Set the name for your project.` (CLI: `--name <name>`)
-    *   `projectDescription`: `Provide a brief description for your project.` (CLI: `--description <text>`)
-    *   `projectVersion`: `Set the initial version for your project, e.g., '0.1.0'.` (CLI: `--version <version>`)
-    *   `authorName`: `Author name.` (CLI: `--author <author>`)
-    *   `skipInstall`: `Skip installing dependencies. Default is false.` (CLI: `--skip-install`)
-    *   `addAliases`: `Add shell aliases tm and taskmaster. Default is false.` (CLI: `--aliases`)
-    *   `yes`: `Skip prompts and use defaults/provided arguments. Default is false.` (CLI: `-y, --yes`)
-*   **Usage:** Run this once at the beginning of a new project, typically via an integrated tool like Windsurf. Operates on the current working directory of the MCP server. 
-*   **Important:** Once complete, you *MUST* parse a prd in order to generate tasks. There will be no tasks files until then. The next step after initializing should be to create a PRD using the example PRD in .taskmaster/templates/example_prd.txt. 
-*   **Tagging:** Use the `--tag` option to parse the PRD into a specific, non-default tag context. If the tag doesn't exist, it will be created automatically. Example: `task-master parse-prd spec.txt --tag=new-feature`.
-
-### 2. Parse PRD (`parse_prd`)
-
-*   **MCP Tool:** `parse_prd`
-*   **CLI Command:** `task-master parse-prd [file] [options]`
-*   **Description:** `Parse a Product Requirements Document, PRD, or text file with Taskmaster to automatically generate an initial set of tasks in tasks.json.`
-*   **Key Parameters/Options:**
-    *   `input`: `Path to your PRD or requirements text file that Taskmaster should parse for tasks.` (CLI: `[file]` positional or `-i, --input <file>`)
-    *   `output`: `Specify where Taskmaster should save the generated 'tasks.json' file. Defaults to '.taskmaster/tasks/tasks.json'.` (CLI: `-o, --output <file>`)
-    *   `numTasks`: `Approximate number of top-level tasks Taskmaster should aim to generate from the document.` (CLI: `-n, --num-tasks <number>`)
-    *   `force`: `Use this to allow Taskmaster to overwrite an existing 'tasks.json' without asking for confirmation.` (CLI: `-f, --force`)
-*   **Usage:** Useful for bootstrapping a project from an existing requirements document.
-*   **Notes:** Task Master will strictly adhere to any specific requirements mentioned in the PRD, such as libraries, database schemas, frameworks, tech stacks, etc., while filling in any gaps where the PRD isn't fully specified. Tasks are designed to provide the most direct implementation path while avoiding over-engineering.
-*   **Important:** This MCP tool makes AI calls and can take up to a minute to complete. Please inform users to hang tight while the operation is in progress. If the user does not have a PRD, suggest discussing their idea and then use the example PRD in `.taskmaster/templates/example_prd.txt` as a template for creating the PRD based on their idea, for use with `parse-prd`.
-
----
-
-## AI Model Configuration
-
-### 2. Manage Models (`models`)
-*   **MCP Tool:** `models`
-*   **CLI Command:** `task-master models [options]`
-*   **Description:** `View the current AI model configuration or set specific models for different roles (main, research, fallback). Allows setting custom model IDs for Ollama and OpenRouter.`
-*   **Key MCP Parameters/Options:**
-    *   `setMain <model_id>`: `Set the primary model ID for task generation/updates.` (CLI: `--set-main <model_id>`)
-    *   `setResearch <model_id>`: `Set the model ID for research-backed operations.` (CLI: `--set-research <model_id>`)
-    *   `setFallback <model_id>`: `Set the model ID to use if the primary fails.` (CLI: `--set-fallback <model_id>`)
-    *   `ollama <boolean>`: `Indicates the set model ID is a custom Ollama model.` (CLI: `--ollama`)
-    *   `openrouter <boolean>`: `Indicates the set model ID is a custom OpenRouter model.` (CLI: `--openrouter`)
-    *   `listAvailableModels <boolean>`: `If true, lists available models not currently assigned to a role.` (CLI: No direct equivalent; CLI lists available automatically)
-    *   `projectRoot <string>`: `Optional. Absolute path to the project root directory.` (CLI: Determined automatically)
-*   **Key CLI Options:**
-    *   `--set-main <model_id>`: `Set the primary model.`
-    *   `--set-research <model_id>`: `Set the research model.`
-    *   `--set-fallback <model_id>`: `Set the fallback model.`
-    *   `--ollama`: `Specify that the provided model ID is for Ollama (use with --set-*).`
-    *   `--openrouter`: `Specify that the provided model ID is for OpenRouter (use with --set-*). Validates against OpenRouter API.`
-    *   `--bedrock`: `Specify that the provided model ID is for AWS Bedrock (use with --set-*).`
-    *   `--setup`: `Run interactive setup to configure models, including custom Ollama/OpenRouter IDs.`
-*   **Usage (MCP):** Call without set flags to get current config. Use `setMain`, `setResearch`, or `setFallback` with a valid model ID to update the configuration. Use `listAvailableModels: true` to get a list of unassigned models. To set a custom model, provide the model ID and set `ollama: true` or `openrouter: true`.
-*   **Usage (CLI):** Run without flags to view current configuration and available models. Use set flags to update specific roles. Use `--setup` for guided configuration, including custom models. To set a custom model via flags, use `--set-<role>=<model_id>` along with either `--ollama` or `--openrouter`.
-*   **Notes:** Configuration is stored in `.taskmaster/config.json` in the project root. This command/tool modifies that file. Use `listAvailableModels` or `task-master models` to see internally supported models. OpenRouter custom models are validated against their live API. Ollama custom models are not validated live.
-*   **API note:** API keys for selected AI providers (based on their model) need to exist in the mcp.json file to be accessible in MCP context. The API keys must be present in the local .env file for the CLI to be able to read them.
-*   **Model costs:** The costs in supported models are expressed in dollars. An input/output value of 3 is $3.00. A value of 0.8 is $0.80. 
-*   **Warning:** DO NOT MANUALLY EDIT THE .taskmaster/config.json FILE. Use the included commands either in the MCP or CLI format as needed. Always prioritize MCP tools when available and use the CLI as a fallback.
-
----
-
-## Task Listing & Viewing
-
-### 3. Get Tasks (`get_tasks`)
-
-*   **MCP Tool:** `get_tasks`
-*   **CLI Command:** `task-master list [options]`
-*   **Description:** `List your Taskmaster tasks, optionally filtering by status and showing subtasks.`
-*   **Key Parameters/Options:**
-    *   `status`: `Show only Taskmaster tasks matching this status (or multiple statuses, comma-separated), e.g., 'pending' or 'done,in-progress'.` (CLI: `-s, --status <status>`)
-    *   `withSubtasks`: `Include subtasks indented under their parent tasks in the list.` (CLI: `--with-subtasks`)
-    *   `tag`: `Specify which tag context to list tasks from. Defaults to the current active tag.` (CLI: `--tag <name>`)
-    *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
-*   **Usage:** Get an overview of the project status, often used at the start of a work session.
-
-### 4. Get Next Task (`next_task`)
-
-*   **MCP Tool:** `next_task`
-*   **CLI Command:** `task-master next [options]`
-*   **Description:** `Ask Taskmaster to show the next available task you can work on, based on status and completed dependencies.`
-*   **Key Parameters/Options:**
-    *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
-    *   `tag`: `Specify which tag context to use. Defaults to the current active tag.` (CLI: `--tag <name>`)
-*   **Usage:** Identify what to work on next according to the plan.
-
-### 5. Get Task Details (`get_task`)
-
-*   **MCP Tool:** `get_task`
-*   **CLI Command:** `task-master show [id] [options]`
-*   **Description:** `Display detailed information for one or more specific Taskmaster tasks or subtasks by ID.`
-*   **Key Parameters/Options:**
-    *   `id`: `Required. The ID of the Taskmaster task (e.g., '15'), subtask (e.g., '15.2'), or a comma-separated list of IDs ('1,5,10.2') you want to view.` (CLI: `[id]` positional or `-i, --id <id>`)
-    *   `tag`: `Specify which tag context to get the task(s) from. Defaults to the current active tag.` (CLI: `--tag <name>`)
-    *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
-*   **Usage:** Understand the full details for a specific task. When multiple IDs are provided, a summary table is shown.
-*   **CRITICAL INFORMATION** If you need to collect information from multiple tasks, use comma-separated IDs (i.e. 1,2,3) to receive an array of tasks. Do not needlessly get tasks one at a time if you need to get many as that is wasteful.
-
----
-
-## Task Creation & Modification
-
-### 6. Add Task (`add_task`)
-
-*   **MCP Tool:** `add_task`
-*   **CLI Command:** `task-master add-task [options]`
-*   **Description:** `Add a new task to Taskmaster by describing it; AI will structure it.`
-*   **Key Parameters/Options:**
-    *   `prompt`: `Required. Describe the new task you want Taskmaster to create, e.g., "Implement user authentication using JWT".` (CLI: `-p, --prompt <text>`)
-    *   `dependencies`: `Specify the IDs of any Taskmaster tasks that must be completed before this new one can start, e.g., '12,14'.` (CLI: `-d, --dependencies <ids>`)
-    *   `priority`: `Set the priority for the new task: 'high', 'medium', or 'low'. Default is 'medium'.` (CLI: `--priority <priority>`)
-    *   `research`: `Enable Taskmaster to use the research role for potentially more informed task creation.` (CLI: `-r, --research`)
-    *   `tag`: `Specify which tag context to add the task to. Defaults to the current active tag.` (CLI: `--tag <name>`)
-    *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
-*   **Usage:** Quickly add newly identified tasks during development.
-*   **Important:** This MCP tool makes AI calls and can take up to a minute to complete. Please inform users to hang tight while the operation is in progress.
-
-### 7. Add Subtask (`add_subtask`)
-
-*   **MCP Tool:** `add_subtask`
-*   **CLI Command:** `task-master add-subtask [options]`
-*   **Description:** `Add a new subtask to a Taskmaster parent task, or convert an existing task into a subtask.`
-*   **Key Parameters/Options:**
-    *   `id` / `parent`: `Required. The ID of the Taskmaster task that will be the parent.` (MCP: `id`, CLI: `-p, --parent <id>`)
-    *   `taskId`: `Use this if you want to convert an existing top-level Taskmaster task into a subtask of the specified parent.` (CLI: `-i, --task-id <id>`)
-    *   `title`: `Required if not using taskId. The title for the new subtask Taskmaster should create.` (CLI: `-t, --title <title>`)
-    *   `description`: `A brief description for the new subtask.` (CLI: `-d, --description <text>`)
-    *   `details`: `Provide implementation notes or details for the new subtask.` (CLI: `--details <text>`)
-    *   `dependencies`: `Specify IDs of other tasks or subtasks, e.g., '15' or '16.1', that must be done before this new subtask.` (CLI: `--dependencies <ids>`)
-    *   `status`: `Set the initial status for the new subtask. Default is 'pending'.` (CLI: `-s, --status <status>`)
-    *   `skipGenerate`: `Prevent Taskmaster from automatically regenerating markdown task files after adding the subtask.` (CLI: `--skip-generate`)
-    *   `tag`: `Specify which tag context to operate on. Defaults to the current active tag.` (CLI: `--tag <name>`)
-    *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
-*   **Usage:** Break down tasks manually or reorganize existing tasks.
-
-### 8. Update Tasks (`update`)
-
-*   **MCP Tool:** `update`
-*   **CLI Command:** `task-master update [options]`
-*   **Description:** `Update multiple upcoming tasks in Taskmaster based on new context or changes, starting from a specific task ID.`
-*   **Key Parameters/Options:**
-    *   `from`: `Required. The ID of the first task Taskmaster should update. All tasks with this ID or higher that are not 'done' will be considered.` (CLI: `--from <id>`)
-    *   `prompt`: `Required. Explain the change or new context for Taskmaster to apply to the tasks, e.g., "We are now using React Query instead of Redux Toolkit for data fetching".` (CLI: `-p, --prompt <text>`)
-    *   `research`: `Enable Taskmaster to use the research role for more informed updates. Requires appropriate API key.` (CLI: `-r, --research`)
-    *   `tag`: `Specify which tag context to operate on. Defaults to the current active tag.` (CLI: `--tag <name>`)
-    *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
-*   **Usage:** Handle significant implementation changes or pivots that affect multiple future tasks. Example CLI: `task-master update --from='18' --prompt='Switching to React Query.\nNeed to refactor data fetching...'`
-*   **Important:** This MCP tool makes AI calls and can take up to a minute to complete. Please inform users to hang tight while the operation is in progress.
-
-### 9. Update Task (`update_task`)
-
-*   **MCP Tool:** `update_task`
-*   **CLI Command:** `task-master update-task [options]`
-*   **Description:** `Modify a specific Taskmaster task by ID, incorporating new information or changes. By default, this replaces the existing task details.`
-*   **Key Parameters/Options:**
-    *   `id`: `Required. The specific ID of the Taskmaster task, e.g., '15', you want to update.` (CLI: `-i, --id <id>`)
-    *   `prompt`: `Required. Explain the specific changes or provide the new information Taskmaster should incorporate into this task.` (CLI: `-p, --prompt <text>`)
-    *   `append`: `If true, appends the prompt content to the task's details with a timestamp, rather than replacing them. Behaves like update-subtask.` (CLI: `--append`)
-    *   `research`: `Enable Taskmaster to use the research role for more informed updates. Requires appropriate API key.` (CLI: `-r, --research`)
-    *   `tag`: `Specify which tag context the task belongs to. Defaults to the current active tag.` (CLI: `--tag <name>`)
-    *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
-*   **Usage:** Refine a specific task based on new understanding. Use `--append` to log progress without creating subtasks.
-*   **Important:** This MCP tool makes AI calls and can take up to a minute to complete. Please inform users to hang tight while the operation is in progress.
-
-### 10. Update Subtask (`update_subtask`)
-
-*   **MCP Tool:** `update_subtask`
-*   **CLI Command:** `task-master update-subtask [options]`
-*   **Description:** `Append timestamped notes or details to a specific Taskmaster subtask without overwriting existing content. Intended for iterative implementation logging.`
-*   **Key Parameters/Options:**
-    *   `id`: `Required. The ID of the Taskmaster subtask, e.g., '5.2', to update with new information.` (CLI: `-i, --id <id>`)
-    *   `prompt`: `Required. The information, findings, or progress notes to append to the subtask's details with a timestamp.` (CLI: `-p, --prompt <text>`)
-    *   `research`: `Enable Taskmaster to use the research role for more informed updates. Requires appropriate API key.` (CLI: `-r, --research`)
-    *   `tag`: `Specify which tag context the subtask belongs to. Defaults to the current active tag.` (CLI: `--tag <name>`)
-    *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
-*   **Usage:** Log implementation progress, findings, and discoveries during subtask development. Each update is timestamped and appended to preserve the implementation journey.
-*   **Important:** This MCP tool makes AI calls and can take up to a minute to complete. Please inform users to hang tight while the operation is in progress.
-
-### 11. Set Task Status (`set_task_status`)
-
-*   **MCP Tool:** `set_task_status`
-*   **CLI Command:** `task-master set-status [options]`
-*   **Description:** `Update the status of one or more Taskmaster tasks or subtasks, e.g., 'pending', 'in-progress', 'done'.`
-*   **Key Parameters/Options:**
-    *   `id`: `Required. The ID(s) of the Taskmaster task(s) or subtask(s), e.g., '15', '15.2', or '16,17.1', to update.` (CLI: `-i, --id <id>`)
-    *   `status`: `Required. The new status to set, e.g., 'done', 'pending', 'in-progress', 'review', 'cancelled'.` (CLI: `-s, --status <status>`)
-    *   `tag`: `Specify which tag context to operate on. Defaults to the current active tag.` (CLI: `--tag <name>`)
-    *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
-*   **Usage:** Mark progress as tasks move through the development cycle.
-
-### 12. Remove Task (`remove_task`)
-
-*   **MCP Tool:** `remove_task`
-*   **CLI Command:** `task-master remove-task [options]`
-*   **Description:** `Permanently remove a task or subtask from the Taskmaster tasks list.`
-*   **Key Parameters/Options:**
-    *   `id`: `Required. The ID of the Taskmaster task, e.g., '5', or subtask, e.g., '5.2', to permanently remove.` (CLI: `-i, --id <id>`)
-    *   `yes`: `Skip the confirmation prompt and immediately delete the task.` (CLI: `-y, --yes`)
-    *   `tag`: `Specify which tag context to operate on. Defaults to the current active tag.` (CLI: `--tag <name>`)
-    *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
-*   **Usage:** Permanently delete tasks or subtasks that are no longer needed in the project.
-*   **Notes:** Use with caution as this operation cannot be undone. Consider using 'blocked', 'cancelled', or 'deferred' status instead if you just want to exclude a task from active planning but keep it for reference. The command automatically cleans up dependency references in other tasks.
-
----
-
-## Task Structure & Breakdown
-
-### 13. Expand Task (`expand_task`)
-
-*   **MCP Tool:** `expand_task`
-*   **CLI Command:** `task-master expand [options]`
-*   **Description:** `Use Taskmaster's AI to break down a complex task into smaller, manageable subtasks. Appends subtasks by default.`
-*   **Key Parameters/Options:**
-    *   `id`: `The ID of the specific Taskmaster task you want to break down into subtasks.` (CLI: `-i, --id <id>`)
-    *   `num`: `Optional: Suggests how many subtasks Taskmaster should aim to create. Uses complexity analysis/defaults otherwise.` (CLI: `-n, --num <number>`)
-    *   `research`: `Enable Taskmaster to use the research role for more informed subtask generation. Requires appropriate API key.` (CLI: `-r, --research`)
-    *   `prompt`: `Optional: Provide extra context or specific instructions to Taskmaster for generating the subtasks.` (CLI: `-p, --prompt <text>`)
-    *   `force`: `Optional: If true, clear existing subtasks before generating new ones. Default is false (append).` (CLI: `--force`)
-    *   `tag`: `Specify which tag context the task belongs to. Defaults to the current active tag.` (CLI: `--tag <name>`)
-    *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
-*   **Usage:** Generate a detailed implementation plan for a complex task before starting coding. Automatically uses complexity report recommendations if available and `num` is not specified.
-*   **Important:** This MCP tool makes AI calls and can take up to a minute to complete. Please inform users to hang tight while the operation is in progress.
-
-### 14. Expand All Tasks (`expand_all`)
-
-*   **MCP Tool:** `expand_all`
-*   **CLI Command:** `task-master expand --all [options]` (Note: CLI uses the `expand` command with the `--all` flag)
-*   **Description:** `Tell Taskmaster to automatically expand all eligible pending/in-progress tasks based on complexity analysis or defaults. Appends subtasks by default.`
-*   **Key Parameters/Options:**
-    *   `num`: `Optional: Suggests how many subtasks Taskmaster should aim to create per task.` (CLI: `-n, --num <number>`)
-    *   `research`: `Enable research role for more informed subtask generation. Requires appropriate API key.` (CLI: `-r, --research`)
-    *   `prompt`: `Optional: Provide extra context for Taskmaster to apply generally during expansion.` (CLI: `-p, --prompt <text>`)
-    *   `force`: `Optional: If true, clear existing subtasks before generating new ones for each eligible task. Default is false (append).` (CLI: `--force`)
-    *   `tag`: `Specify which tag context to expand. Defaults to the current active tag.` (CLI: `--tag <name>`)
-    *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
-*   **Usage:** Useful after initial task generation or complexity analysis to break down multiple tasks at once.
-*   **Important:** This MCP tool makes AI calls and can take up to a minute to complete. Please inform users to hang tight while the operation is in progress.
-
-### 15. Clear Subtasks (`clear_subtasks`)
-
-*   **MCP Tool:** `clear_subtasks`
-*   **CLI Command:** `task-master clear-subtasks [options]`
-*   **Description:** `Remove all subtasks from one or more specified Taskmaster parent tasks.`
-*   **Key Parameters/Options:**
-    *   `id`: `The ID(s) of the Taskmaster parent task(s) whose subtasks you want to remove, e.g., '15' or '16,18'. Required unless using `all`.) (CLI: `-i, --id <ids>`)
-    *   `all`: `Tell Taskmaster to remove subtasks from all parent tasks.` (CLI: `--all`)
-    *   `tag`: `Specify which tag context to operate on. Defaults to the current active tag.` (CLI: `--tag <name>`)
-    *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
-*   **Usage:** Used before regenerating subtasks with `expand_task` if the previous breakdown needs replacement.
-
-### 16. Remove Subtask (`remove_subtask`)
-
-*   **MCP Tool:** `remove_subtask`
-*   **CLI Command:** `task-master remove-subtask [options]`
-*   **Description:** `Remove a subtask from its Taskmaster parent, optionally converting it into a standalone task.`
-*   **Key Parameters/Options:**
-    *   `id`: `Required. The ID(s) of the Taskmaster subtask(s) to remove, e.g., '15.2' or '16.1,16.3'.` (CLI: `-i, --id <id>`)
-    *   `convert`: `If used, Taskmaster will turn the subtask into a regular top-level task instead of deleting it.` (CLI: `-c, --convert`)
-    *   `skipGenerate`: `Prevent Taskmaster from automatically regenerating markdown task files after removing the subtask.` (CLI: `--skip-generate`)
-    *   `tag`: `Specify which tag context to operate on. Defaults to the current active tag.` (CLI: `--tag <name>`)
-    *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
-*   **Usage:** Delete unnecessary subtasks or promote a subtask to a top-level task.
-
-### 17. Move Task (`move_task`)
-
-*   **MCP Tool:** `move_task`
-*   **CLI Command:** `task-master move [options]`
-*   **Description:** `Move a task or subtask to a new position within the task hierarchy.`
-*   **Key Parameters/Options:**
-    *   `from`: `Required. ID of the task/subtask to move (e.g., "5" or "5.2"). Can be comma-separated for multiple tasks.` (CLI: `--from <id>`)
-    *   `to`: `Required. ID of the destination (e.g., "7" or "7.3"). Must match the number of source IDs if comma-separated.` (CLI: `--to <id>`)
-    *   `tag`: `Specify which tag context to operate on. Defaults to the current active tag.` (CLI: `--tag <name>`)
-    *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
-*   **Usage:** Reorganize tasks by moving them within the hierarchy. Supports various scenarios like:
-    *   Moving a task to become a subtask
-    *   Moving a subtask to become a standalone task
-    *   Moving a subtask to a different parent
-    *   Reordering subtasks within the same parent
-    *   Moving a task to a new, non-existent ID (automatically creates placeholders)
-    *   Moving multiple tasks at once with comma-separated IDs
-*   **Validation Features:**
-    *   Allows moving tasks to non-existent destination IDs (creates placeholder tasks)
-    *   Prevents moving to existing task IDs that already have content (to avoid overwriting)
-    *   Validates that source tasks exist before attempting to move them
-    *   Maintains proper parent-child relationships
-*   **Example CLI:** `task-master move --from=5.2 --to=7.3` to move subtask 5.2 to become subtask 7.3.
-*   **Example Multi-Move:** `task-master move --from=10,11,12 --to=16,17,18` to move multiple tasks to new positions.
-*   **Common Use:** Resolving merge conflicts in tasks.json when multiple team members create tasks on different branches.
-
----
-
-## Dependency Management
-
-### 18. Add Dependency (`add_dependency`)
-
-*   **MCP Tool:** `add_dependency`
-*   **CLI Command:** `task-master add-dependency [options]`
-*   **Description:** `Define a dependency in Taskmaster, making one task a prerequisite for another.`
-*   **Key Parameters/Options:**
-    *   `id`: `Required. The ID of the Taskmaster task that will depend on another.` (CLI: `-i, --id <id>`)
-    *   `dependsOn`: `Required. The ID of the Taskmaster task that must be completed first, the prerequisite.` (CLI: `-d, --depends-on <id>`)
-    *   `tag`: `Specify which tag context to operate on. Defaults to the current active tag.` (CLI: `--tag <name>`)
-    *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <path>`)
-*   **Usage:** Establish the correct order of execution between tasks.
-
-### 19. Remove Dependency (`remove_dependency`)
-
-*   **MCP Tool:** `remove_dependency`
-*   **CLI Command:** `task-master remove-dependency [options]`
-*   **Description:** `Remove a dependency relationship between two Taskmaster tasks.`
-*   **Key Parameters/Options:**
-    *   `id`: `Required. The ID of the Taskmaster task you want to remove a prerequisite from.` (CLI: `-i, --id <id>`)
-    *   `dependsOn`: `Required. The ID of the Taskmaster task that should no longer be a prerequisite.` (CLI: `-d, --depends-on <id>`)
-    *   `tag`: `Specify which tag context to operate on. Defaults to the current active tag.` (CLI: `--tag <name>`)
-    *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
-*   **Usage:** Update task relationships when the order of execution changes.
-
-### 20. Validate Dependencies (`validate_dependencies`)
-
-*   **MCP Tool:** `validate_dependencies`
-*   **CLI Command:** `task-master validate-dependencies [options]`
-*   **Description:** `Check your Taskmaster tasks for dependency issues (like circular references or links to non-existent tasks) without making changes.`
-*   **Key Parameters/Options:**
-    *   `tag`: `Specify which tag context to validate. Defaults to the current active tag.` (CLI: `--tag <name>`)
-    *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
-*   **Usage:** Audit the integrity of your task dependencies.
-
-### 21. Fix Dependencies (`fix_dependencies`)
-
-*   **MCP Tool:** `fix_dependencies`
-*   **CLI Command:** `task-master fix-dependencies [options]`
-*   **Description:** `Automatically fix dependency issues (like circular references or links to non-existent tasks) in your Taskmaster tasks.`
-*   **Key Parameters/Options:**
-    *   `tag`: `Specify which tag context to fix dependencies in. Defaults to the current active tag.` (CLI: `--tag <name>`)
-    *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
-*   **Usage:** Clean up dependency errors automatically.
-
----
-
-## Analysis & Reporting
-
-### 22. Analyze Project Complexity (`analyze_project_complexity`)
-
-*   **MCP Tool:** `analyze_project_complexity`
-*   **CLI Command:** `task-master analyze-complexity [options]`
-*   **Description:** `Have Taskmaster analyze your tasks to determine their complexity and suggest which ones need to be broken down further.`
-*   **Key Parameters/Options:**
-    *   `output`: `Where to save the complexity analysis report. Default is '.taskmaster/reports/task-complexity-report.json' (or '..._tagname.json' if a tag is used).` (CLI: `-o, --output <file>`)
-    *   `threshold`: `The minimum complexity score (1-10) that should trigger a recommendation to expand a task.` (CLI: `-t, --threshold <number>`)
-    *   `research`: `Enable research role for more accurate complexity analysis. Requires appropriate API key.` (CLI: `-r, --research`)
-    *   `tag`: `Specify which tag context to analyze. Defaults to the current active tag.` (CLI: `--tag <name>`)
-    *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
-*   **Usage:** Used before breaking down tasks to identify which ones need the most attention.
-*   **Important:** This MCP tool makes AI calls and can take up to a minute to complete. Please inform users to hang tight while the operation is in progress.
-
-### 23. View Complexity Report (`complexity_report`)
-
-*   **MCP Tool:** `complexity_report`
-*   **CLI Command:** `task-master complexity-report [options]`
-*   **Description:** `Display the task complexity analysis report in a readable format.`
-*   **Key Parameters/Options:**
-    *   `tag`: `Specify which tag context to show the report for. Defaults to the current active tag.` (CLI: `--tag <name>`)
-    *   `file`: `Path to the complexity report (default: '.taskmaster/reports/task-complexity-report.json').` (CLI: `-f, --file <file>`)
-*   **Usage:** Review and understand the complexity analysis results after running analyze-complexity.
-
----
-
-## File Management
-
-### 24. Generate Task Files (`generate`)
-
-*   **MCP Tool:** `generate`
-*   **CLI Command:** `task-master generate [options]`
-*   **Description:** `Create or update individual Markdown files for each task based on your tasks.json.`
-*   **Key Parameters/Options:**
-    *   `output`: `The directory where Taskmaster should save the task files (default: in a 'tasks' directory).` (CLI: `-o, --output <directory>`)
-    *   `tag`: `Specify which tag context to generate files for. Defaults to the current active tag.` (CLI: `--tag <name>`)
-    *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
-*   **Usage:** Run this after making changes to tasks.json to keep individual task files up to date. This command is now manual and no longer runs automatically.
-
----
-
-## AI-Powered Research
-
-### 25. Research (`research`)
-
-*   **MCP Tool:** `research`
-*   **CLI Command:** `task-master research [options]`
-*   **Description:** `Perform AI-powered research queries with project context to get fresh, up-to-date information beyond the AI's knowledge cutoff.`
-*   **Key Parameters/Options:**
-    *   `query`: `Required. Research query/prompt (e.g., "What are the latest best practices for React Query v5?").` (CLI: `[query]` positional or `-q, --query <text>`)
-    *   `taskIds`: `Comma-separated list of task/subtask IDs from the current tag context (e.g., "15,16.2,17").` (CLI: `-i, --id <ids>`)
-    *   `filePaths`: `Comma-separated list of file paths for context (e.g., "src/api.js,docs/readme.md").` (CLI: `-f, --files <paths>`)
-    *   `customContext`: `Additional custom context text to include in the research.` (CLI: `-c, --context <text>`)
-    *   `includeProjectTree`: `Include project file tree structure in context (default: false).` (CLI: `--tree`)
-    *   `detailLevel`: `Detail level for the research response: 'low', 'medium', 'high' (default: medium).` (CLI: `--detail <level>`)
-    *   `saveTo`: `Task or subtask ID (e.g., "15", "15.2") to automatically save the research conversation to.` (CLI: `--save-to <id>`)
-    *   `saveFile`: `If true, saves the research conversation to a markdown file in '.taskmaster/docs/research/'.` (CLI: `--save-file`)
-    *   `noFollowup`: `Disables the interactive follow-up question menu in the CLI.` (CLI: `--no-followup`)
-    *   `tag`: `Specify which tag context to use for task-based context gathering. Defaults to the current active tag.` (CLI: `--tag <name>`)
-    *   `projectRoot`: `The directory of the project. Must be an absolute path.` (CLI: Determined automatically)
-*   **Usage:** **This is a POWERFUL tool that agents should use FREQUENTLY** to:
-    *   Get fresh information beyond knowledge cutoff dates
-    *   Research latest best practices, library updates, security patches
-    *   Find implementation examples for specific technologies
-    *   Validate approaches against current industry standards
-    *   Get contextual advice based on project files and tasks
-*   **When to Consider Using Research:**
-    *   **Before implementing any task** - Research current best practices
-    *   **When encountering new technologies** - Get up-to-date implementation guidance (libraries, apis, etc)
-    *   **For security-related tasks** - Find latest security recommendations
-    *   **When updating dependencies** - Research breaking changes and migration guides
-    *   **For performance optimization** - Get current performance best practices
-    *   **When debugging complex issues** - Research known solutions and workarounds
-*   **Research + Action Pattern:**
-    *   Use `research` to gather fresh information
-    *   Use `update_subtask` to commit findings with timestamps
-    *   Use `update_task` to incorporate research into task details
-    *   Use `add_task` with research flag for informed task creation
-*   **Important:** This MCP tool makes AI calls and can take up to a minute to complete. The research provides FRESH data beyond the AI's training cutoff, making it invaluable for current best practices and recent developments.
-
----
-
-## Tag Management
-
-This new suite of commands allows you to manage different task contexts (tags).
-
-### 26. List Tags (`tags`)
-
-*   **MCP Tool:** `list_tags`
-*   **CLI Command:** `task-master tags [options]`
-*   **Description:** `List all available tags with task counts, completion status, and other metadata.`
-*   **Key Parameters/Options:**
-    *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
-    *   `--show-metadata`: `Include detailed metadata in the output (e.g., creation date, description).` (CLI: `--show-metadata`)
-
-### 27. Add Tag (`add_tag`)
-
-*   **MCP Tool:** `add_tag`
-*   **CLI Command:** `task-master add-tag <tagName> [options]`
-*   **Description:** `Create a new, empty tag context, or copy tasks from another tag.`
-*   **Key Parameters/Options:**
-    *   `tagName`: `Name of the new tag to create (alphanumeric, hyphens, underscores).` (CLI: `<tagName>` positional)
-    *   `--from-branch`: `Creates a tag with a name derived from the current git branch, ignoring the <tagName> argument.` (CLI: `--from-branch`)
-    *   `--copy-from-current`: `Copy tasks from the currently active tag to the new tag.` (CLI: `--copy-from-current`)
-    *   `--copy-from <tag>`: `Copy tasks from a specific source tag to the new tag.` (CLI: `--copy-from <tag>`)
-    *   `--description <text>`: `Provide an optional description for the new tag.` (CLI: `-d, --description <text>`)
-    *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
-
-### 28. Delete Tag (`delete_tag`)
-
-*   **MCP Tool:** `delete_tag`
-*   **CLI Command:** `task-master delete-tag <tagName> [options]`
-*   **Description:** `Permanently delete a tag and all of its associated tasks.`
-*   **Key Parameters/Options:**
-    *   `tagName`: `Name of the tag to delete.` (CLI: `<tagName>` positional)
-    *   `--yes`: `Skip the confirmation prompt.` (CLI: `-y, --yes`)
-    *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
-
-### 29. Use Tag (`use_tag`)
-
-*   **MCP Tool:** `use_tag`
-*   **CLI Command:** `task-master use-tag <tagName>`
-*   **Description:** `Switch your active task context to a different tag.`
-*   **Key Parameters/Options:**
-    *   `tagName`: `Name of the tag to switch to.` (CLI: `<tagName>` positional)
-    *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
-
-### 30. Rename Tag (`rename_tag`)
-
-*   **MCP Tool:** `rename_tag`
-*   **CLI Command:** `task-master rename-tag <oldName> <newName>`
-*   **Description:** `Rename an existing tag.`
-*   **Key Parameters/Options:**
-    *   `oldName`: `The current name of the tag.` (CLI: `<oldName>` positional)
-    *   `newName`: `The new name for the tag.` (CLI: `<newName>` positional)
-    *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
-
-### 31. Copy Tag (`copy_tag`)
-
-*   **MCP Tool:** `copy_tag`
-*   **CLI Command:** `task-master copy-tag <sourceName> <targetName> [options]`
-*   **Description:** `Copy an entire tag context, including all its tasks and metadata, to a new tag.`
-*   **Key Parameters/Options:**
-    *   `sourceName`: `Name of the tag to copy from.` (CLI: `<sourceName>` positional)
-    *   `targetName`: `Name of the new tag to create.` (CLI: `<targetName>` positional)
-    *   `--description <text>`: `Optional description for the new tag.` (CLI: `-d, --description <text>`)
-
----
-
-## Miscellaneous
-
-### 32. Sync Readme (`sync-readme`) -- experimental
-
-*   **MCP Tool:** N/A
-*   **CLI Command:** `task-master sync-readme [options]`
-*   **Description:** `Exports your task list to your project's README.md file, useful for showcasing progress.`
-*   **Key Parameters/Options:**
-    *   `status`: `Filter tasks by status (e.g., 'pending', 'done').` (CLI: `-s, --status <status>`)
-    *   `withSubtasks`: `Include subtasks in the export.` (CLI: `--with-subtasks`)
-    *   `tag`: `Specify which tag context to export from. Defaults to the current active tag.` (CLI: `--tag <name>`)
-
----
-
-## Environment Variables Configuration (Updated)
-
-Taskmaster primarily uses the **`.taskmaster/config.json`** file (in project root) for configuration (models, parameters, logging level, etc.), managed via `task-master models --setup`.
-
-Environment variables are used **only** for sensitive API keys related to AI providers and specific overrides like the Ollama base URL:
-
-*   **API Keys (Required for corresponding provider):**
-    *   `ANTHROPIC_API_KEY`
-    *   `PERPLEXITY_API_KEY`
-    *   `OPENAI_API_KEY`
-    *   `GOOGLE_API_KEY`
-    *   `MISTRAL_API_KEY`
-    *   `AZURE_OPENAI_API_KEY` (Requires `AZURE_OPENAI_ENDPOINT` too)
-    *   `OPENROUTER_API_KEY`
-    *   `XAI_API_KEY`
-    *   `OLLAMA_API_KEY` (Requires `OLLAMA_BASE_URL` too)
-*   **Endpoints (Optional/Provider Specific inside .taskmaster/config.json):**
-    *   `AZURE_OPENAI_ENDPOINT`
-    *   `OLLAMA_BASE_URL` (Default: `http://localhost:11434/api`)
-
-**Set API keys** in your **`.env`** file in the project root (for CLI use) or within the `env` section of your **`.windsurf/mcp.json`** file (for MCP/Windsurf integration). All other settings (model choice, max tokens, temperature, log level, custom endpoints) are managed in `.taskmaster/config.json` via `task-master models` command or `models` MCP tool.
-
----
-
-For details on how these commands fit into the development process, see the [dev_workflow.md](.windsurf/rules/dev_workflow.md).
\ No newline at end of file
diff --git a/tmp_repo_contents/taskmaster.mdc b/tmp_repo_contents/taskmaster.mdc
deleted file mode 100644
index 3ac9bab..0000000
--- a/tmp_repo_contents/taskmaster.mdc
+++ /dev/null
@@ -1,558 +0,0 @@
----
-description: Comprehensive reference for Taskmaster MCP tools and CLI commands.
-globs: **/*
-alwaysApply: true
----
-
-# Taskmaster Tool & Command Reference
-
-This document provides a detailed reference for interacting with Taskmaster, covering both the recommended MCP tools, suitable for integrations like Cursor, and the corresponding `task-master` CLI commands, designed for direct user interaction or fallback.
-
-**Note:** For interacting with Taskmaster programmatically or via integrated tools, using the **MCP tools is strongly recommended** due to better performance, structured data, and error handling. The CLI commands serve as a user-friendly alternative and fallback. 
-
-**Important:** Several MCP tools involve AI processing... The AI-powered tools include `parse_prd`, `analyze_project_complexity`, `update_subtask`, `update_task`, `update`, `expand_all`, `expand_task`, and `add_task`.
-
-**🏷️ Tagged Task Lists System:** Task Master now supports **tagged task lists** for multi-context task management. This allows you to maintain separate, isolated lists of tasks for different features, branches, or experiments. Existing projects are seamlessly migrated to use a default "master" tag. Most commands now support a `--tag <name>` flag to specify which context to operate on. If omitted, commands use the currently active tag.
-
----
-
-## Initialization & Setup
-
-### 1. Initialize Project (`init`)
-
-*   **MCP Tool:** `initialize_project`
-*   **CLI Command:** `task-master init [options]`
-*   **Description:** `Set up the basic Taskmaster file structure and configuration in the current directory for a new project.`
-*   **Key CLI Options:**
-    *   `--name <name>`: `Set the name for your project in Taskmaster's configuration.`
-    *   `--description <text>`: `Provide a brief description for your project.`
-    *   `--version <version>`: `Set the initial version for your project, e.g., '0.1.0'.`
-    *   `-y, --yes`: `Initialize Taskmaster quickly using default settings without interactive prompts.`
-*   **Usage:** Run this once at the beginning of a new project.
-*   **MCP Variant Description:** `Set up the basic Taskmaster file structure and configuration in the current directory for a new project by running the 'task-master init' command.`
-*   **Key MCP Parameters/Options:**
-    *   `projectName`: `Set the name for your project.` (CLI: `--name <name>`)
-    *   `projectDescription`: `Provide a brief description for your project.` (CLI: `--description <text>`)
-    *   `projectVersion`: `Set the initial version for your project, e.g., '0.1.0'.` (CLI: `--version <version>`)
-    *   `authorName`: `Author name.` (CLI: `--author <author>`)
-    *   `skipInstall`: `Skip installing dependencies. Default is false.` (CLI: `--skip-install`)
-    *   `addAliases`: `Add shell aliases tm and taskmaster. Default is false.` (CLI: `--aliases`)
-    *   `yes`: `Skip prompts and use defaults/provided arguments. Default is false.` (CLI: `-y, --yes`)
-*   **Usage:** Run this once at the beginning of a new project, typically via an integrated tool like Cursor. Operates on the current working directory of the MCP server. 
-*   **Important:** Once complete, you *MUST* parse a prd in order to generate tasks. There will be no tasks files until then. The next step after initializing should be to create a PRD using the example PRD in .taskmaster/templates/example_prd.txt. 
-*   **Tagging:** Use the `--tag` option to parse the PRD into a specific, non-default tag context. If the tag doesn't exist, it will be created automatically. Example: `task-master parse-prd spec.txt --tag=new-feature`.
-
-### 2. Parse PRD (`parse_prd`)
-
-*   **MCP Tool:** `parse_prd`
-*   **CLI Command:** `task-master parse-prd [file] [options]`
-*   **Description:** `Parse a Product Requirements Document, PRD, or text file with Taskmaster to automatically generate an initial set of tasks in tasks.json.`
-*   **Key Parameters/Options:**
-    *   `input`: `Path to your PRD or requirements text file that Taskmaster should parse for tasks.` (CLI: `[file]` positional or `-i, --input <file>`)
-    *   `output`: `Specify where Taskmaster should save the generated 'tasks.json' file. Defaults to '.taskmaster/tasks/tasks.json'.` (CLI: `-o, --output <file>`)
-    *   `numTasks`: `Approximate number of top-level tasks Taskmaster should aim to generate from the document.` (CLI: `-n, --num-tasks <number>`)
-    *   `force`: `Use this to allow Taskmaster to overwrite an existing 'tasks.json' without asking for confirmation.` (CLI: `-f, --force`)
-*   **Usage:** Useful for bootstrapping a project from an existing requirements document.
-*   **Notes:** Task Master will strictly adhere to any specific requirements mentioned in the PRD, such as libraries, database schemas, frameworks, tech stacks, etc., while filling in any gaps where the PRD isn't fully specified. Tasks are designed to provide the most direct implementation path while avoiding over-engineering.
-*   **Important:** This MCP tool makes AI calls and can take up to a minute to complete. Please inform users to hang tight while the operation is in progress. If the user does not have a PRD, suggest discussing their idea and then use the example PRD in `.taskmaster/templates/example_prd.txt` as a template for creating the PRD based on their idea, for use with `parse-prd`.
-
----
-
-## AI Model Configuration
-
-### 2. Manage Models (`models`)
-*   **MCP Tool:** `models`
-*   **CLI Command:** `task-master models [options]`
-*   **Description:** `View the current AI model configuration or set specific models for different roles (main, research, fallback). Allows setting custom model IDs for Ollama and OpenRouter.`
-*   **Key MCP Parameters/Options:**
-    *   `setMain <model_id>`: `Set the primary model ID for task generation/updates.` (CLI: `--set-main <model_id>`)
-    *   `setResearch <model_id>`: `Set the model ID for research-backed operations.` (CLI: `--set-research <model_id>`)
-    *   `setFallback <model_id>`: `Set the model ID to use if the primary fails.` (CLI: `--set-fallback <model_id>`)
-    *   `ollama <boolean>`: `Indicates the set model ID is a custom Ollama model.` (CLI: `--ollama`)
-    *   `openrouter <boolean>`: `Indicates the set model ID is a custom OpenRouter model.` (CLI: `--openrouter`)
-    *   `listAvailableModels <boolean>`: `If true, lists available models not currently assigned to a role.` (CLI: No direct equivalent; CLI lists available automatically)
-    *   `projectRoot <string>`: `Optional. Absolute path to the project root directory.` (CLI: Determined automatically)
-*   **Key CLI Options:**
-    *   `--set-main <model_id>`: `Set the primary model.`
-    *   `--set-research <model_id>`: `Set the research model.`
-    *   `--set-fallback <model_id>`: `Set the fallback model.`
-    *   `--ollama`: `Specify that the provided model ID is for Ollama (use with --set-*).`
-    *   `--openrouter`: `Specify that the provided model ID is for OpenRouter (use with --set-*). Validates against OpenRouter API.`
-    *   `--bedrock`: `Specify that the provided model ID is for AWS Bedrock (use with --set-*).`
-    *   `--setup`: `Run interactive setup to configure models, including custom Ollama/OpenRouter IDs.`
-*   **Usage (MCP):** Call without set flags to get current config. Use `setMain`, `setResearch`, or `setFallback` with a valid model ID to update the configuration. Use `listAvailableModels: true` to get a list of unassigned models. To set a custom model, provide the model ID and set `ollama: true` or `openrouter: true`.
-*   **Usage (CLI):** Run without flags to view current configuration and available models. Use set flags to update specific roles. Use `--setup` for guided configuration, including custom models. To set a custom model via flags, use `--set-<role>=<model_id>` along with either `--ollama` or `--openrouter`.
-*   **Notes:** Configuration is stored in `.taskmaster/config.json` in the project root. This command/tool modifies that file. Use `listAvailableModels` or `task-master models` to see internally supported models. OpenRouter custom models are validated against their live API. Ollama custom models are not validated live.
-*   **API note:** API keys for selected AI providers (based on their model) need to exist in the mcp.json file to be accessible in MCP context. The API keys must be present in the local .env file for the CLI to be able to read them.
-*   **Model costs:** The costs in supported models are expressed in dollars. An input/output value of 3 is $3.00. A value of 0.8 is $0.80. 
-*   **Warning:** DO NOT MANUALLY EDIT THE .taskmaster/config.json FILE. Use the included commands either in the MCP or CLI format as needed. Always prioritize MCP tools when available and use the CLI as a fallback.
-
----
-
-## Task Listing & Viewing
-
-### 3. Get Tasks (`get_tasks`)
-
-*   **MCP Tool:** `get_tasks`
-*   **CLI Command:** `task-master list [options]`
-*   **Description:** `List your Taskmaster tasks, optionally filtering by status and showing subtasks.`
-*   **Key Parameters/Options:**
-    *   `status`: `Show only Taskmaster tasks matching this status (or multiple statuses, comma-separated), e.g., 'pending' or 'done,in-progress'.` (CLI: `-s, --status <status>`)
-    *   `withSubtasks`: `Include subtasks indented under their parent tasks in the list.` (CLI: `--with-subtasks`)
-    *   `tag`: `Specify which tag context to list tasks from. Defaults to the current active tag.` (CLI: `--tag <name>`)
-    *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
-*   **Usage:** Get an overview of the project status, often used at the start of a work session.
-
-### 4. Get Next Task (`next_task`)
-
-*   **MCP Tool:** `next_task`
-*   **CLI Command:** `task-master next [options]`
-*   **Description:** `Ask Taskmaster to show the next available task you can work on, based on status and completed dependencies.`
-*   **Key Parameters/Options:**
-    *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
-    *   `tag`: `Specify which tag context to use. Defaults to the current active tag.` (CLI: `--tag <name>`)
-*   **Usage:** Identify what to work on next according to the plan.
-
-### 5. Get Task Details (`get_task`)
-
-*   **MCP Tool:** `get_task`
-*   **CLI Command:** `task-master show [id] [options]`
-*   **Description:** `Display detailed information for one or more specific Taskmaster tasks or subtasks by ID.`
-*   **Key Parameters/Options:**
-    *   `id`: `Required. The ID of the Taskmaster task (e.g., '15'), subtask (e.g., '15.2'), or a comma-separated list of IDs ('1,5,10.2') you want to view.` (CLI: `[id]` positional or `-i, --id <id>`)
-    *   `tag`: `Specify which tag context to get the task(s) from. Defaults to the current active tag.` (CLI: `--tag <name>`)
-    *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
-*   **Usage:** Understand the full details for a specific task. When multiple IDs are provided, a summary table is shown.
-*   **CRITICAL INFORMATION** If you need to collect information from multiple tasks, use comma-separated IDs (i.e. 1,2,3) to receive an array of tasks. Do not needlessly get tasks one at a time if you need to get many as that is wasteful.
-
----
-
-## Task Creation & Modification
-
-### 6. Add Task (`add_task`)
-
-*   **MCP Tool:** `add_task`
-*   **CLI Command:** `task-master add-task [options]`
-*   **Description:** `Add a new task to Taskmaster by describing it; AI will structure it.`
-*   **Key Parameters/Options:**
-    *   `prompt`: `Required. Describe the new task you want Taskmaster to create, e.g., "Implement user authentication using JWT".` (CLI: `-p, --prompt <text>`)
-    *   `dependencies`: `Specify the IDs of any Taskmaster tasks that must be completed before this new one can start, e.g., '12,14'.` (CLI: `-d, --dependencies <ids>`)
-    *   `priority`: `Set the priority for the new task: 'high', 'medium', or 'low'. Default is 'medium'.` (CLI: `--priority <priority>`)
-    *   `research`: `Enable Taskmaster to use the research role for potentially more informed task creation.` (CLI: `-r, --research`)
-    *   `tag`: `Specify which tag context to add the task to. Defaults to the current active tag.` (CLI: `--tag <name>`)
-    *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
-*   **Usage:** Quickly add newly identified tasks during development.
-*   **Important:** This MCP tool makes AI calls and can take up to a minute to complete. Please inform users to hang tight while the operation is in progress.
-
-### 7. Add Subtask (`add_subtask`)
-
-*   **MCP Tool:** `add_subtask`
-*   **CLI Command:** `task-master add-subtask [options]`
-*   **Description:** `Add a new subtask to a Taskmaster parent task, or convert an existing task into a subtask.`
-*   **Key Parameters/Options:**
-    *   `id` / `parent`: `Required. The ID of the Taskmaster task that will be the parent.` (MCP: `id`, CLI: `-p, --parent <id>`)
-    *   `taskId`: `Use this if you want to convert an existing top-level Taskmaster task into a subtask of the specified parent.` (CLI: `-i, --task-id <id>`)
-    *   `title`: `Required if not using taskId. The title for the new subtask Taskmaster should create.` (CLI: `-t, --title <title>`)
-    *   `description`: `A brief description for the new subtask.` (CLI: `-d, --description <text>`)
-    *   `details`: `Provide implementation notes or details for the new subtask.` (CLI: `--details <text>`)
-    *   `dependencies`: `Specify IDs of other tasks or subtasks, e.g., '15' or '16.1', that must be done before this new subtask.` (CLI: `--dependencies <ids>`)
-    *   `status`: `Set the initial status for the new subtask. Default is 'pending'.` (CLI: `-s, --status <status>`)
-    *   `skipGenerate`: `Prevent Taskmaster from automatically regenerating markdown task files after adding the subtask.` (CLI: `--skip-generate`)
-    *   `tag`: `Specify which tag context to operate on. Defaults to the current active tag.` (CLI: `--tag <name>`)
-    *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
-*   **Usage:** Break down tasks manually or reorganize existing tasks.
-
-### 8. Update Tasks (`update`)
-
-*   **MCP Tool:** `update`
-*   **CLI Command:** `task-master update [options]`
-*   **Description:** `Update multiple upcoming tasks in Taskmaster based on new context or changes, starting from a specific task ID.`
-*   **Key Parameters/Options:**
-    *   `from`: `Required. The ID of the first task Taskmaster should update. All tasks with this ID or higher that are not 'done' will be considered.` (CLI: `--from <id>`)
-    *   `prompt`: `Required. Explain the change or new context for Taskmaster to apply to the tasks, e.g., "We are now using React Query instead of Redux Toolkit for data fetching".` (CLI: `-p, --prompt <text>`)
-    *   `research`: `Enable Taskmaster to use the research role for more informed updates. Requires appropriate API key.` (CLI: `-r, --research`)
-    *   `tag`: `Specify which tag context to operate on. Defaults to the current active tag.` (CLI: `--tag <name>`)
-    *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
-*   **Usage:** Handle significant implementation changes or pivots that affect multiple future tasks. Example CLI: `task-master update --from='18' --prompt='Switching to React Query.\nNeed to refactor data fetching...'`
-*   **Important:** This MCP tool makes AI calls and can take up to a minute to complete. Please inform users to hang tight while the operation is in progress.
-
-### 9. Update Task (`update_task`)
-
-*   **MCP Tool:** `update_task`
-*   **CLI Command:** `task-master update-task [options]`
-*   **Description:** `Modify a specific Taskmaster task by ID, incorporating new information or changes. By default, this replaces the existing task details.`
-*   **Key Parameters/Options:**
-    *   `id`: `Required. The specific ID of the Taskmaster task, e.g., '15', you want to update.` (CLI: `-i, --id <id>`)
-    *   `prompt`: `Required. Explain the specific changes or provide the new information Taskmaster should incorporate into this task.` (CLI: `-p, --prompt <text>`)
-    *   `append`: `If true, appends the prompt content to the task's details with a timestamp, rather than replacing them. Behaves like update-subtask.` (CLI: `--append`)
-    *   `research`: `Enable Taskmaster to use the research role for more informed updates. Requires appropriate API key.` (CLI: `-r, --research`)
-    *   `tag`: `Specify which tag context the task belongs to. Defaults to the current active tag.` (CLI: `--tag <name>`)
-    *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
-*   **Usage:** Refine a specific task based on new understanding. Use `--append` to log progress without creating subtasks.
-*   **Important:** This MCP tool makes AI calls and can take up to a minute to complete. Please inform users to hang tight while the operation is in progress.
-
-### 10. Update Subtask (`update_subtask`)
-
-*   **MCP Tool:** `update_subtask`
-*   **CLI Command:** `task-master update-subtask [options]`
-*   **Description:** `Append timestamped notes or details to a specific Taskmaster subtask without overwriting existing content. Intended for iterative implementation logging.`
-*   **Key Parameters/Options:**
-    *   `id`: `Required. The ID of the Taskmaster subtask, e.g., '5.2', to update with new information.` (CLI: `-i, --id <id>`)
-    *   `prompt`: `Required. The information, findings, or progress notes to append to the subtask's details with a timestamp.` (CLI: `-p, --prompt <text>`)
-    *   `research`: `Enable Taskmaster to use the research role for more informed updates. Requires appropriate API key.` (CLI: `-r, --research`)
-    *   `tag`: `Specify which tag context the subtask belongs to. Defaults to the current active tag.` (CLI: `--tag <name>`)
-    *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
-*   **Usage:** Log implementation progress, findings, and discoveries during subtask development. Each update is timestamped and appended to preserve the implementation journey.
-*   **Important:** This MCP tool makes AI calls and can take up to a minute to complete. Please inform users to hang tight while the operation is in progress.
-
-### 11. Set Task Status (`set_task_status`)
-
-*   **MCP Tool:** `set_task_status`
-*   **CLI Command:** `task-master set-status [options]`
-*   **Description:** `Update the status of one or more Taskmaster tasks or subtasks, e.g., 'pending', 'in-progress', 'done'.`
-*   **Key Parameters/Options:**
-    *   `id`: `Required. The ID(s) of the Taskmaster task(s) or subtask(s), e.g., '15', '15.2', or '16,17.1', to update.` (CLI: `-i, --id <id>`)
-    *   `status`: `Required. The new status to set, e.g., 'done', 'pending', 'in-progress', 'review', 'cancelled'.` (CLI: `-s, --status <status>`)
-    *   `tag`: `Specify which tag context to operate on. Defaults to the current active tag.` (CLI: `--tag <name>`)
-    *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
-*   **Usage:** Mark progress as tasks move through the development cycle.
-
-### 12. Remove Task (`remove_task`)
-
-*   **MCP Tool:** `remove_task`
-*   **CLI Command:** `task-master remove-task [options]`
-*   **Description:** `Permanently remove a task or subtask from the Taskmaster tasks list.`
-*   **Key Parameters/Options:**
-    *   `id`: `Required. The ID of the Taskmaster task, e.g., '5', or subtask, e.g., '5.2', to permanently remove.` (CLI: `-i, --id <id>`)
-    *   `yes`: `Skip the confirmation prompt and immediately delete the task.` (CLI: `-y, --yes`)
-    *   `tag`: `Specify which tag context to operate on. Defaults to the current active tag.` (CLI: `--tag <name>`)
-    *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
-*   **Usage:** Permanently delete tasks or subtasks that are no longer needed in the project.
-*   **Notes:** Use with caution as this operation cannot be undone. Consider using 'blocked', 'cancelled', or 'deferred' status instead if you just want to exclude a task from active planning but keep it for reference. The command automatically cleans up dependency references in other tasks.
-
----
-
-## Task Structure & Breakdown
-
-### 13. Expand Task (`expand_task`)
-
-*   **MCP Tool:** `expand_task`
-*   **CLI Command:** `task-master expand [options]`
-*   **Description:** `Use Taskmaster's AI to break down a complex task into smaller, manageable subtasks. Appends subtasks by default.`
-*   **Key Parameters/Options:**
-    *   `id`: `The ID of the specific Taskmaster task you want to break down into subtasks.` (CLI: `-i, --id <id>`)
-    *   `num`: `Optional: Suggests how many subtasks Taskmaster should aim to create. Uses complexity analysis/defaults otherwise.` (CLI: `-n, --num <number>`)
-    *   `research`: `Enable Taskmaster to use the research role for more informed subtask generation. Requires appropriate API key.` (CLI: `-r, --research`)
-    *   `prompt`: `Optional: Provide extra context or specific instructions to Taskmaster for generating the subtasks.` (CLI: `-p, --prompt <text>`)
-    *   `force`: `Optional: If true, clear existing subtasks before generating new ones. Default is false (append).` (CLI: `--force`)
-    *   `tag`: `Specify which tag context the task belongs to. Defaults to the current active tag.` (CLI: `--tag <name>`)
-    *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
-*   **Usage:** Generate a detailed implementation plan for a complex task before starting coding. Automatically uses complexity report recommendations if available and `num` is not specified.
-*   **Important:** This MCP tool makes AI calls and can take up to a minute to complete. Please inform users to hang tight while the operation is in progress.
-
-### 14. Expand All Tasks (`expand_all`)
-
-*   **MCP Tool:** `expand_all`
-*   **CLI Command:** `task-master expand --all [options]` (Note: CLI uses the `expand` command with the `--all` flag)
-*   **Description:** `Tell Taskmaster to automatically expand all eligible pending/in-progress tasks based on complexity analysis or defaults. Appends subtasks by default.`
-*   **Key Parameters/Options:**
-    *   `num`: `Optional: Suggests how many subtasks Taskmaster should aim to create per task.` (CLI: `-n, --num <number>`)
-    *   `research`: `Enable research role for more informed subtask generation. Requires appropriate API key.` (CLI: `-r, --research`)
-    *   `prompt`: `Optional: Provide extra context for Taskmaster to apply generally during expansion.` (CLI: `-p, --prompt <text>`)
-    *   `force`: `Optional: If true, clear existing subtasks before generating new ones for each eligible task. Default is false (append).` (CLI: `--force`)
-    *   `tag`: `Specify which tag context to expand. Defaults to the current active tag.` (CLI: `--tag <name>`)
-    *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
-*   **Usage:** Useful after initial task generation or complexity analysis to break down multiple tasks at once.
-*   **Important:** This MCP tool makes AI calls and can take up to a minute to complete. Please inform users to hang tight while the operation is in progress.
-
-### 15. Clear Subtasks (`clear_subtasks`)
-
-*   **MCP Tool:** `clear_subtasks`
-*   **CLI Command:** `task-master clear-subtasks [options]`
-*   **Description:** `Remove all subtasks from one or more specified Taskmaster parent tasks.`
-*   **Key Parameters/Options:**
-    *   `id`: `The ID(s) of the Taskmaster parent task(s) whose subtasks you want to remove, e.g., '15' or '16,18'. Required unless using `all`.) (CLI: `-i, --id <ids>`)
-    *   `all`: `Tell Taskmaster to remove subtasks from all parent tasks.` (CLI: `--all`)
-    *   `tag`: `Specify which tag context to operate on. Defaults to the current active tag.` (CLI: `--tag <name>`)
-    *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
-*   **Usage:** Used before regenerating subtasks with `expand_task` if the previous breakdown needs replacement.
-
-### 16. Remove Subtask (`remove_subtask`)
-
-*   **MCP Tool:** `remove_subtask`
-*   **CLI Command:** `task-master remove-subtask [options]`
-*   **Description:** `Remove a subtask from its Taskmaster parent, optionally converting it into a standalone task.`
-*   **Key Parameters/Options:**
-    *   `id`: `Required. The ID(s) of the Taskmaster subtask(s) to remove, e.g., '15.2' or '16.1,16.3'.` (CLI: `-i, --id <id>`)
-    *   `convert`: `If used, Taskmaster will turn the subtask into a regular top-level task instead of deleting it.` (CLI: `-c, --convert`)
-    *   `skipGenerate`: `Prevent Taskmaster from automatically regenerating markdown task files after removing the subtask.` (CLI: `--skip-generate`)
-    *   `tag`: `Specify which tag context to operate on. Defaults to the current active tag.` (CLI: `--tag <name>`)
-    *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
-*   **Usage:** Delete unnecessary subtasks or promote a subtask to a top-level task.
-
-### 17. Move Task (`move_task`)
-
-*   **MCP Tool:** `move_task`
-*   **CLI Command:** `task-master move [options]`
-*   **Description:** `Move a task or subtask to a new position within the task hierarchy.`
-*   **Key Parameters/Options:**
-    *   `from`: `Required. ID of the task/subtask to move (e.g., "5" or "5.2"). Can be comma-separated for multiple tasks.` (CLI: `--from <id>`)
-    *   `to`: `Required. ID of the destination (e.g., "7" or "7.3"). Must match the number of source IDs if comma-separated.` (CLI: `--to <id>`)
-    *   `tag`: `Specify which tag context to operate on. Defaults to the current active tag.` (CLI: `--tag <name>`)
-    *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
-*   **Usage:** Reorganize tasks by moving them within the hierarchy. Supports various scenarios like:
-    *   Moving a task to become a subtask
-    *   Moving a subtask to become a standalone task
-    *   Moving a subtask to a different parent
-    *   Reordering subtasks within the same parent
-    *   Moving a task to a new, non-existent ID (automatically creates placeholders)
-    *   Moving multiple tasks at once with comma-separated IDs
-*   **Validation Features:**
-    *   Allows moving tasks to non-existent destination IDs (creates placeholder tasks)
-    *   Prevents moving to existing task IDs that already have content (to avoid overwriting)
-    *   Validates that source tasks exist before attempting to move them
-    *   Maintains proper parent-child relationships
-*   **Example CLI:** `task-master move --from=5.2 --to=7.3` to move subtask 5.2 to become subtask 7.3.
-*   **Example Multi-Move:** `task-master move --from=10,11,12 --to=16,17,18` to move multiple tasks to new positions.
-*   **Common Use:** Resolving merge conflicts in tasks.json when multiple team members create tasks on different branches.
-
----
-
-## Dependency Management
-
-### 18. Add Dependency (`add_dependency`)
-
-*   **MCP Tool:** `add_dependency`
-*   **CLI Command:** `task-master add-dependency [options]`
-*   **Description:** `Define a dependency in Taskmaster, making one task a prerequisite for another.`
-*   **Key Parameters/Options:**
-    *   `id`: `Required. The ID of the Taskmaster task that will depend on another.` (CLI: `-i, --id <id>`)
-    *   `dependsOn`: `Required. The ID of the Taskmaster task that must be completed first, the prerequisite.` (CLI: `-d, --depends-on <id>`)
-    *   `tag`: `Specify which tag context to operate on. Defaults to the current active tag.` (CLI: `--tag <name>`)
-    *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <path>`)
-*   **Usage:** Establish the correct order of execution between tasks.
-
-### 19. Remove Dependency (`remove_dependency`)
-
-*   **MCP Tool:** `remove_dependency`
-*   **CLI Command:** `task-master remove-dependency [options]`
-*   **Description:** `Remove a dependency relationship between two Taskmaster tasks.`
-*   **Key Parameters/Options:**
-    *   `id`: `Required. The ID of the Taskmaster task you want to remove a prerequisite from.` (CLI: `-i, --id <id>`)
-    *   `dependsOn`: `Required. The ID of the Taskmaster task that should no longer be a prerequisite.` (CLI: `-d, --depends-on <id>`)
-    *   `tag`: `Specify which tag context to operate on. Defaults to the current active tag.` (CLI: `--tag <name>`)
-    *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
-*   **Usage:** Update task relationships when the order of execution changes.
-
-### 20. Validate Dependencies (`validate_dependencies`)
-
-*   **MCP Tool:** `validate_dependencies`
-*   **CLI Command:** `task-master validate-dependencies [options]`
-*   **Description:** `Check your Taskmaster tasks for dependency issues (like circular references or links to non-existent tasks) without making changes.`
-*   **Key Parameters/Options:**
-    *   `tag`: `Specify which tag context to validate. Defaults to the current active tag.` (CLI: `--tag <name>`)
-    *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
-*   **Usage:** Audit the integrity of your task dependencies.
-
-### 21. Fix Dependencies (`fix_dependencies`)
-
-*   **MCP Tool:** `fix_dependencies`
-*   **CLI Command:** `task-master fix-dependencies [options]`
-*   **Description:** `Automatically fix dependency issues (like circular references or links to non-existent tasks) in your Taskmaster tasks.`
-*   **Key Parameters/Options:**
-    *   `tag`: `Specify which tag context to fix dependencies in. Defaults to the current active tag.` (CLI: `--tag <name>`)
-    *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
-*   **Usage:** Clean up dependency errors automatically.
-
----
-
-## Analysis & Reporting
-
-### 22. Analyze Project Complexity (`analyze_project_complexity`)
-
-*   **MCP Tool:** `analyze_project_complexity`
-*   **CLI Command:** `task-master analyze-complexity [options]`
-*   **Description:** `Have Taskmaster analyze your tasks to determine their complexity and suggest which ones need to be broken down further.`
-*   **Key Parameters/Options:**
-    *   `output`: `Where to save the complexity analysis report. Default is '.taskmaster/reports/task-complexity-report.json' (or '..._tagname.json' if a tag is used).` (CLI: `-o, --output <file>`)
-    *   `threshold`: `The minimum complexity score (1-10) that should trigger a recommendation to expand a task.` (CLI: `-t, --threshold <number>`)
-    *   `research`: `Enable research role for more accurate complexity analysis. Requires appropriate API key.` (CLI: `-r, --research`)
-    *   `tag`: `Specify which tag context to analyze. Defaults to the current active tag.` (CLI: `--tag <name>`)
-    *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
-*   **Usage:** Used before breaking down tasks to identify which ones need the most attention.
-*   **Important:** This MCP tool makes AI calls and can take up to a minute to complete. Please inform users to hang tight while the operation is in progress.
-
-### 23. View Complexity Report (`complexity_report`)
-
-*   **MCP Tool:** `complexity_report`
-*   **CLI Command:** `task-master complexity-report [options]`
-*   **Description:** `Display the task complexity analysis report in a readable format.`
-*   **Key Parameters/Options:**
-    *   `tag`: `Specify which tag context to show the report for. Defaults to the current active tag.` (CLI: `--tag <name>`)
-    *   `file`: `Path to the complexity report (default: '.taskmaster/reports/task-complexity-report.json').` (CLI: `-f, --file <file>`)
-*   **Usage:** Review and understand the complexity analysis results after running analyze-complexity.
-
----
-
-## File Management
-
-### 24. Generate Task Files (`generate`)
-
-*   **MCP Tool:** `generate`
-*   **CLI Command:** `task-master generate [options]`
-*   **Description:** `Create or update individual Markdown files for each task based on your tasks.json.`
-*   **Key Parameters/Options:**
-    *   `output`: `The directory where Taskmaster should save the task files (default: in a 'tasks' directory).` (CLI: `-o, --output <directory>`)
-    *   `tag`: `Specify which tag context to generate files for. Defaults to the current active tag.` (CLI: `--tag <name>`)
-    *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
-*   **Usage:** Run this after making changes to tasks.json to keep individual task files up to date. This command is now manual and no longer runs automatically.
-
----
-
-## AI-Powered Research
-
-### 25. Research (`research`)
-
-*   **MCP Tool:** `research`
-*   **CLI Command:** `task-master research [options]`
-*   **Description:** `Perform AI-powered research queries with project context to get fresh, up-to-date information beyond the AI's knowledge cutoff.`
-*   **Key Parameters/Options:**
-    *   `query`: `Required. Research query/prompt (e.g., "What are the latest best practices for React Query v5?").` (CLI: `[query]` positional or `-q, --query <text>`)
-    *   `taskIds`: `Comma-separated list of task/subtask IDs from the current tag context (e.g., "15,16.2,17").` (CLI: `-i, --id <ids>`)
-    *   `filePaths`: `Comma-separated list of file paths for context (e.g., "src/api.js,docs/readme.md").` (CLI: `-f, --files <paths>`)
-    *   `customContext`: `Additional custom context text to include in the research.` (CLI: `-c, --context <text>`)
-    *   `includeProjectTree`: `Include project file tree structure in context (default: false).` (CLI: `--tree`)
-    *   `detailLevel`: `Detail level for the research response: 'low', 'medium', 'high' (default: medium).` (CLI: `--detail <level>`)
-    *   `saveTo`: `Task or subtask ID (e.g., "15", "15.2") to automatically save the research conversation to.` (CLI: `--save-to <id>`)
-    *   `saveFile`: `If true, saves the research conversation to a markdown file in '.taskmaster/docs/research/'.` (CLI: `--save-file`)
-    *   `noFollowup`: `Disables the interactive follow-up question menu in the CLI.` (CLI: `--no-followup`)
-    *   `tag`: `Specify which tag context to use for task-based context gathering. Defaults to the current active tag.` (CLI: `--tag <name>`)
-    *   `projectRoot`: `The directory of the project. Must be an absolute path.` (CLI: Determined automatically)
-*   **Usage:** **This is a POWERFUL tool that agents should use FREQUENTLY** to:
-    *   Get fresh information beyond knowledge cutoff dates
-    *   Research latest best practices, library updates, security patches
-    *   Find implementation examples for specific technologies
-    *   Validate approaches against current industry standards
-    *   Get contextual advice based on project files and tasks
-*   **When to Consider Using Research:**
-    *   **Before implementing any task** - Research current best practices
-    *   **When encountering new technologies** - Get up-to-date implementation guidance (libraries, apis, etc)
-    *   **For security-related tasks** - Find latest security recommendations
-    *   **When updating dependencies** - Research breaking changes and migration guides
-    *   **For performance optimization** - Get current performance best practices
-    *   **When debugging complex issues** - Research known solutions and workarounds
-*   **Research + Action Pattern:**
-    *   Use `research` to gather fresh information
-    *   Use `update_subtask` to commit findings with timestamps
-    *   Use `update_task` to incorporate research into task details
-    *   Use `add_task` with research flag for informed task creation
-*   **Important:** This MCP tool makes AI calls and can take up to a minute to complete. The research provides FRESH data beyond the AI's training cutoff, making it invaluable for current best practices and recent developments.
-
----
-
-## Tag Management
-
-This new suite of commands allows you to manage different task contexts (tags).
-
-### 26. List Tags (`tags`)
-
-*   **MCP Tool:** `list_tags`
-*   **CLI Command:** `task-master tags [options]`
-*   **Description:** `List all available tags with task counts, completion status, and other metadata.`
-*   **Key Parameters/Options:**
-    *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
-    *   `--show-metadata`: `Include detailed metadata in the output (e.g., creation date, description).` (CLI: `--show-metadata`)
-
-### 27. Add Tag (`add_tag`)
-
-*   **MCP Tool:** `add_tag`
-*   **CLI Command:** `task-master add-tag <tagName> [options]`
-*   **Description:** `Create a new, empty tag context, or copy tasks from another tag.`
-*   **Key Parameters/Options:**
-    *   `tagName`: `Name of the new tag to create (alphanumeric, hyphens, underscores).` (CLI: `<tagName>` positional)
-    *   `--from-branch`: `Creates a tag with a name derived from the current git branch, ignoring the <tagName> argument.` (CLI: `--from-branch`)
-    *   `--copy-from-current`: `Copy tasks from the currently active tag to the new tag.` (CLI: `--copy-from-current`)
-    *   `--copy-from <tag>`: `Copy tasks from a specific source tag to the new tag.` (CLI: `--copy-from <tag>`)
-    *   `--description <text>`: `Provide an optional description for the new tag.` (CLI: `-d, --description <text>`)
-    *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
-
-### 28. Delete Tag (`delete_tag`)
-
-*   **MCP Tool:** `delete_tag`
-*   **CLI Command:** `task-master delete-tag <tagName> [options]`
-*   **Description:** `Permanently delete a tag and all of its associated tasks.`
-*   **Key Parameters/Options:**
-    *   `tagName`: `Name of the tag to delete.` (CLI: `<tagName>` positional)
-    *   `--yes`: `Skip the confirmation prompt.` (CLI: `-y, --yes`)
-    *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
-
-### 29. Use Tag (`use_tag`)
-
-*   **MCP Tool:** `use_tag`
-*   **CLI Command:** `task-master use-tag <tagName>`
-*   **Description:** `Switch your active task context to a different tag.`
-*   **Key Parameters/Options:**
-    *   `tagName`: `Name of the tag to switch to.` (CLI: `<tagName>` positional)
-    *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
-
-### 30. Rename Tag (`rename_tag`)
-
-*   **MCP Tool:** `rename_tag`
-*   **CLI Command:** `task-master rename-tag <oldName> <newName>`
-*   **Description:** `Rename an existing tag.`
-*   **Key Parameters/Options:**
-    *   `oldName`: `The current name of the tag.` (CLI: `<oldName>` positional)
-    *   `newName`: `The new name for the tag.` (CLI: `<newName>` positional)
-    *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
-
-### 31. Copy Tag (`copy_tag`)
-
-*   **MCP Tool:** `copy_tag`
-*   **CLI Command:** `task-master copy-tag <sourceName> <targetName> [options]`
-*   **Description:** `Copy an entire tag context, including all its tasks and metadata, to a new tag.`
-*   **Key Parameters/Options:**
-    *   `sourceName`: `Name of the tag to copy from.` (CLI: `<sourceName>` positional)
-    *   `targetName`: `Name of the new tag to create.` (CLI: `<targetName>` positional)
-    *   `--description <text>`: `Optional description for the new tag.` (CLI: `-d, --description <text>`)
-
----
-
-## Miscellaneous
-
-### 32. Sync Readme (`sync-readme`) -- experimental
-
-*   **MCP Tool:** N/A
-*   **CLI Command:** `task-master sync-readme [options]`
-*   **Description:** `Exports your task list to your project's README.md file, useful for showcasing progress.`
-*   **Key Parameters/Options:**
-    *   `status`: `Filter tasks by status (e.g., 'pending', 'done').` (CLI: `-s, --status <status>`)
-    *   `withSubtasks`: `Include subtasks in the export.` (CLI: `--with-subtasks`)
-    *   `tag`: `Specify which tag context to export from. Defaults to the current active tag.` (CLI: `--tag <name>`)
-
----
-
-## Environment Variables Configuration (Updated)
-
-Taskmaster primarily uses the **`.taskmaster/config.json`** file (in project root) for configuration (models, parameters, logging level, etc.), managed via `task-master models --setup`.
-
-Environment variables are used **only** for sensitive API keys related to AI providers and specific overrides like the Ollama base URL:
-
-*   **API Keys (Required for corresponding provider):**
-    *   `ANTHROPIC_API_KEY`
-    *   `PERPLEXITY_API_KEY`
-    *   `OPENAI_API_KEY`
-    *   `GOOGLE_API_KEY`
-    *   `MISTRAL_API_KEY`
-    *   `AZURE_OPENAI_API_KEY` (Requires `AZURE_OPENAI_ENDPOINT` too)
-    *   `OPENROUTER_API_KEY`
-    *   `XAI_API_KEY`
-    *   `OLLAMA_API_KEY` (Requires `OLLAMA_BASE_URL` too)
-*   **Endpoints (Optional/Provider Specific inside .taskmaster/config.json):**
-    *   `AZURE_OPENAI_ENDPOINT`
-    *   `OLLAMA_BASE_URL` (Default: `http://localhost:11434/api`)
-
-**Set API keys** in your **`.env`** file in the project root (for CLI use) or within the `env` section of your **`.cursor/mcp.json`** file (for MCP/Cursor integration). All other settings (model choice, max tokens, temperature, log level, custom endpoints) are managed in `.taskmaster/config.json` via `task-master models` command or `models` MCP tool.
-
----
-
-For details on how these commands fit into the development process, see the [dev_workflow.mdc](mdc:.cursor/rules/taskmaster/dev_workflow.mdc).
\ No newline at end of file
diff --git a/tmp_repo_contents/tasks.json b/tmp_repo_contents/tasks.json
deleted file mode 100644
index 7e596bc..0000000
--- a/tmp_repo_contents/tasks.json
+++ /dev/null
@@ -1,671 +0,0 @@
-{
-  "master": {
-    "tasks": [
-      {
-        "id": 1,
-        "title": "Setup Custom Frappe App Structure",
-        "description": "Create the initial structure for the custom Frappe app that will contain the modern UI theme for ERPNext.",
-        "details": "1. Create a new Frappe app using the bench command: `bench new-app erpnext_modern_ui`\n2. Set up the basic directory structure:\n   - `erpnext_modern_ui/`\n     - `public/`\n       - `css/`\n       - `js/`\n     - `templates/`\n     - `hooks.py`\n     - `__init__.py`\n3. Configure app metadata in `setup.py`\n4. Initialize Git repository\n5. Create a README.md with installation and usage instructions\n6. Set up the hooks.py file with initial configuration to inject CSS and JS files",
-        "testStrategy": "Verify the app can be installed on a test ERPNext instance using `bench get-app` and `bench install-app`. Ensure the basic structure is recognized by Frappe and no errors appear during installation.",
-        "priority": "high",
-        "dependencies": [],
-        "status": "done",
-        "subtasks": [
-          {
-            "id": 1,
-            "title": "Create Initial App Structure",
-            "description": "Set up the basic directory structure for a new Frappe custom app",
-            "dependencies": [],
-            "details": "Use the bench new-app command to create the initial app structure. Ensure proper naming convention following Frappe standards. Verify the creation of essential directories including controllers, templates, www, and config. Test the app installation with bench install-app.",
-            "status": "done",
-            "testStrategy": ""
-          },
-          {
-            "id": 2,
-            "title": "Configure App Metadata and Hooks",
-            "description": "Set up the app's configuration files with proper metadata and hook definitions",
-            "dependencies": [
-              1
-            ],
-            "details": "Edit hooks.py to define necessary hooks for the app's functionality. Update app.py with appropriate metadata including app name, title, description, version, and dependencies. Configure config files with default settings. Set up proper module structure for DocTypes and other components.",
-            "status": "done",
-            "testStrategy": ""
-          },
-          {
-            "id": 3,
-            "title": "Set Up Documentation and Version Control",
-            "description": "Create documentation files and initialize version control for the app",
-            "dependencies": [
-              2
-            ],
-            "details": "Create a comprehensive README.md with installation instructions, features, and usage examples. Set up license file appropriate for the project. Initialize git repository for the app. Create .gitignore file with appropriate exclusions for Frappe apps. Add initial commit with proper commit message describing the app structure.",
-            "status": "done",
-            "testStrategy": ""
-          }
-        ]
-      },
-      {
-        "id": 2,
-        "title": "Define Modern Color Palette and Typography",
-        "description": "Create a comprehensive color system and typography guidelines inspired by ClickUp's clean and modern aesthetic.",
-        "details": "1. Research ClickUp's color scheme and create a similar palette with:\n   - Primary color: Modern blue (#7B68EE or similar)\n   - Secondary colors: Complementary accent colors\n   - Neutral colors: Various shades of gray and white\n   - Status colors: Success, warning, error, info\n2. Define CSS variables for all colors in a `variables.css` file\n3. Select and implement modern typography:\n   - Primary font: Inter or similar sans-serif font\n   - Define font sizes for different UI elements (headings, body text, labels, etc.)\n   - Set appropriate line heights and letter spacing\n4. Create a style guide document with color codes and typography specifications\n5. Implement CSS utility classes for colors and typography",
-        "testStrategy": "Create a test page that displays all color variables and typography styles. Verify the colors match the ClickUp-inspired palette and the typography is consistent and readable across different browsers and screen sizes.",
-        "priority": "high",
-        "dependencies": [
-          1
-        ],
-        "status": "done",
-        "subtasks": [
-          {
-            "id": 1,
-            "title": "Research and Define Color Palette",
-            "description": "Research modern color trends and define a comprehensive color palette for the application",
-            "dependencies": [],
-            "details": "Research current design trends and color theory. Define primary, secondary, and accent colors. Include semantic colors for success, warning, error, and info states. Consider accessibility requirements (WCAG) for color contrast. Create color variations (light/dark) for each main color.",
-            "status": "done",
-            "testStrategy": ""
-          },
-          {
-            "id": 2,
-            "title": "Select and Implement Typography",
-            "description": "Choose appropriate font families and define typography scales for the application",
-            "dependencies": [],
-            "details": "Research web-safe and Google fonts that align with the brand. Define font families for headings, body text, and UI elements. Create a typographic scale with appropriate sizes for different screen sizes. Consider line heights, letter spacing, and font weights for readability. Test typography across different devices and browsers.",
-            "status": "done",
-            "testStrategy": ""
-          },
-          {
-            "id": 3,
-            "title": "Create CSS Variables and Utility Classes",
-            "description": "Implement the color palette and typography as CSS custom properties and utility classes",
-            "dependencies": [
-              1,
-              2
-            ],
-            "details": "Create CSS custom properties (variables) for all colors and typography values. Develop utility classes for colors (text colors, background colors). Create typography utility classes for headings, paragraphs, and UI text. Ensure the system works with both light and dark modes. Test implementation across browsers for compatibility.",
-            "status": "done",
-            "testStrategy": ""
-          },
-          {
-            "id": 4,
-            "title": "Document Style Guide",
-            "description": "Create comprehensive documentation for the color palette and typography system",
-            "dependencies": [
-              1,
-              2,
-              3
-            ],
-            "details": "Create a visual style guide showing all colors with their hex/RGB values and CSS variable names. Document typography with examples of all text styles and their CSS classes. Include usage guidelines and best practices for implementing colors and typography. Add examples of color combinations that meet accessibility standards. Ensure the documentation is accessible to both designers and developers.",
-            "status": "done",
-            "testStrategy": ""
-          }
-        ]
-      },
-      {
-        "id": 3,
-        "title": "Redesign Main Navigation Sidebar",
-        "description": "Overhaul the main sidebar to be cleaner and more organized with better visual hierarchy and modern styling.",
-        "details": "1. Create CSS overrides for the main sidebar in `sidebar.css`:\n   - Implement cleaner spacing and padding\n   - Style module icons with the new color palette\n   - Improve visual hierarchy with better typography\n   - Add hover and active states with subtle animations\n2. If needed, create JavaScript enhancements in `sidebar.js` to:\n   - Improve collapsible sections\n   - Enhance icon display\n   - Add any necessary DOM manipulations\n3. Use Frappe hooks to inject these files into the desk:\n```python\n# In hooks.py\napp_include_css = [\n    \"/assets/erpnext_modern_ui/css/variables.css\",\n    \"/assets/erpnext_modern_ui/css/sidebar.css\"\n]\napp_include_js = [\n    \"/assets/erpnext_modern_ui/js/sidebar.js\"\n]\n```\n4. Consider using a modern icon set like Feather Icons for consistency",
-        "testStrategy": "Test the sidebar on different screen sizes to ensure responsiveness. Verify all modules are accessible and that the visual styling matches the ClickUp-inspired design. Check that hover and active states work correctly and that the sidebar behaves properly when collapsed and expanded.",
-        "priority": "high",
-        "dependencies": [
-          2
-        ],
-        "status": "done",
-        "subtasks": [
-          {
-            "id": 1,
-            "title": "Implement CSS for Sidebar Structure and Layout",
-            "description": "Redesign the CSS for the main navigation sidebar structure and layout to improve usability and visual hierarchy.",
-            "dependencies": [],
-            "details": "Analyze the current DOM structure of the sidebar. Create new CSS rules for the sidebar container, spacing between elements, and responsive behavior. Implement styles for both collapsed and expanded states. Ensure proper alignment and padding of all elements. Test layout across different screen sizes.",
-            "status": "done",
-            "testStrategy": ""
-          },
-          {
-            "id": 2,
-            "title": "Implement Icon and Typography Styling",
-            "description": "Update the visual presentation of icons and text within the sidebar to improve readability and visual consistency.",
-            "dependencies": [
-              1
-            ],
-            "details": "Select appropriate icon set or optimize existing icons. Implement consistent sizing and alignment for all icons. Update typography styles including font family, size, weight, and line height. Ensure proper contrast ratios for accessibility. Create hover and focus states for text elements.",
-            "status": "done",
-            "testStrategy": ""
-          },
-          {
-            "id": 3,
-            "title": "Develop Interactive Elements and State Styling",
-            "description": "Create styles for interactive elements and different states (hover, active, selected) to improve user feedback and navigation clarity.",
-            "dependencies": [
-              1,
-              2
-            ],
-            "details": "Implement hover effects for navigation items. Create styles for active/selected state indicators. Design transitions between states for smooth user experience. Style dropdown/expandable sections within the sidebar. Ensure all interactive elements have appropriate focus states for accessibility.",
-            "status": "done",
-            "testStrategy": ""
-          },
-          {
-            "id": 4,
-            "title": "Add JavaScript Enhancements for Improved Functionality",
-            "description": "Implement JavaScript functionality to enhance the sidebar's usability and performance.",
-            "dependencies": [
-              3
-            ],
-            "details": "Add smooth transitions when collapsing/expanding the sidebar. Implement state persistence using localStorage to remember user preferences. Create event handlers for navigation interactions. Optimize performance for animations and transitions. Add keyboard navigation support for accessibility. Test all JavaScript enhancements across supported browsers.",
-            "status": "done",
-            "testStrategy": ""
-          }
-        ]
-      },
-      {
-        "id": 4,
-        "title": "Redesign Header and Global Navigation",
-        "description": "Create a streamlined and modern header with improved global navigation elements.",
-        "details": "1. Create CSS overrides for the header in `header.css`:\n   - Implement a cleaner, more streamlined header design\n   - Style the search bar, notification icons, and user menu\n   - Add subtle shadows or borders for visual separation\n   - Ensure proper alignment and spacing of all elements\n2. If needed, create JavaScript enhancements in `header.js` for:\n   - Improved dropdown behaviors\n   - Enhanced search functionality display\n   - Any necessary DOM manipulations\n3. Update hooks.py to include these new files\n4. Ensure the header is fixed at the top and properly responds to scrolling\n5. Style the breadcrumb navigation to be more modern and consistent with the overall design",
-        "testStrategy": "Test the header across different screen sizes to ensure responsiveness. Verify all functionality (search, notifications, user menu, etc.) works correctly with the new styling. Ensure the header looks consistent across different pages and modules.",
-        "priority": "high",
-        "dependencies": [
-          2
-        ],
-        "status": "done",
-        "subtasks": [
-          {
-            "id": 1,
-            "title": "Header Layout and Structure Styling",
-            "description": "Redesign the header container, logo placement, and overall structure according to the new design system",
-            "dependencies": [],
-            "details": "Update the header's HTML structure and CSS styling to match the new design specifications. This includes adjusting the header height, background, borders, shadows, and positioning of main elements. Ensure proper alignment of the logo and main container elements. Update the color scheme to match the new brand guidelines.",
-            "status": "done",
-            "testStrategy": ""
-          },
-          {
-            "id": 2,
-            "title": "Navigation Elements and Search Bar Redesign",
-            "description": "Restyle the main navigation links and implement the new search bar design",
-            "dependencies": [
-              1
-            ],
-            "details": "Redesign the main navigation links with new typography, spacing, and hover states. Implement the updated search bar with new input styling, placeholder text, and search icon. Ensure the search functionality remains intact while updating the visual elements. Add appropriate transitions for hover and focus states.",
-            "status": "done",
-            "testStrategy": ""
-          },
-          {
-            "id": 3,
-            "title": "Dropdown and Interactive Elements Styling",
-            "description": "Update all dropdown menus, notification panels, and user menu components in the header",
-            "dependencies": [
-              2
-            ],
-            "details": "Restyle dropdown menus for navigation items, notification panels, and user profile menu. Implement new animations for dropdown toggles. Update icons for notifications, user avatar, and other interactive elements. Ensure all interactive elements maintain proper functionality while receiving visual updates. Test all dropdown behaviors for consistency.",
-            "status": "done",
-            "testStrategy": ""
-          },
-          {
-            "id": 4,
-            "title": "Responsive Behavior Implementation",
-            "description": "Ensure the header adapts properly across all device sizes with appropriate breakpoints",
-            "dependencies": [
-              3
-            ],
-            "details": "Implement responsive behavior for the header using media queries. Create a mobile-friendly collapsed navigation menu with hamburger icon. Adjust search bar behavior for smaller screens. Test and optimize header display across various device sizes (mobile, tablet, desktop). Ensure smooth transitions between different viewport sizes without layout issues.",
-            "status": "done",
-            "testStrategy": ""
-          }
-        ]
-      },
-      {
-        "id": 5,
-        "title": "Modernize Form Views",
-        "description": "Redesign form layouts to be cleaner with better spacing, modern input fields, buttons, and controls.",
-        "details": "1. Create CSS overrides for form elements in `forms.css`:\n   - Implement modern input styles with appropriate padding and borders\n   - Style buttons according to the new color palette with hover and active states\n   - Improve section breaks and field grouping\n   - Add subtle animations for interactions\n   - Enhance form layout with better spacing and alignment\n2. Style form controls like checkboxes, radio buttons, dropdowns, and date pickers\n3. Improve the visual hierarchy of form sections and tabs\n4. Style form actions (Save, Submit, Cancel) to be more prominent and consistent\n5. Ensure all form elements are accessible and follow modern web standards\n6. If needed, create JavaScript enhancements in `forms.js` for improved interactions",
-        "testStrategy": "Test forms across different modules (Sales Order, Purchase Invoice, etc.) to ensure consistent styling. Verify all form controls work correctly with the new styling. Test form submission and validation to ensure error states are properly displayed. Check accessibility by testing with keyboard navigation and screen readers.",
-        "priority": "medium",
-        "dependencies": [
-          2
-        ],
-        "status": "done",
-        "subtasks": [
-          {
-            "id": 1,
-            "title": "Basic Input Field Styling",
-            "description": "Update the styling of basic input fields (text, email, password, etc.) to match the new design system",
-            "dependencies": [],
-            "details": "Implement consistent styling for text inputs including focus states, placeholder text, and input padding. Update typography to match design system. Ensure consistent height and width across similar input types. Test across browsers for rendering consistency.",
-            "status": "done",
-            "testStrategy": ""
-          },
-          {
-            "id": 2,
-            "title": "Button and Action Element Redesign",
-            "description": "Redesign form buttons and action elements with modern styling and interaction states",
-            "dependencies": [
-              1
-            ],
-            "details": "Update primary, secondary and tertiary button styles. Implement hover, active, focus, and disabled states. Ensure consistent spacing between action elements. Add loading states for submission buttons. Update icon buttons used within forms.",
-            "status": "done",
-            "testStrategy": ""
-          },
-          {
-            "id": 3,
-            "title": "Form Layout and Section Styling",
-            "description": "Improve the overall layout and section styling of forms for better visual hierarchy and organization",
-            "dependencies": [
-              1,
-              2
-            ],
-            "details": "Create consistent spacing between form sections. Design section headers and dividers. Implement responsive layouts that work on mobile and desktop. Update fieldset and legend styling. Create a grid system for multi-column form layouts where appropriate.",
-            "status": "done",
-            "testStrategy": ""
-          },
-          {
-            "id": 4,
-            "title": "Custom Form Controls Implementation",
-            "description": "Redesign and implement custom form controls including checkboxes, radio buttons, toggles, and dropdown menus",
-            "dependencies": [
-              1
-            ],
-            "details": "Create custom styled checkboxes and radio buttons that maintain accessibility. Redesign dropdown/select elements with custom styling. Implement toggle switches as alternatives to checkboxes where appropriate. Style multi-select components and date pickers.",
-            "status": "done",
-            "testStrategy": ""
-          },
-          {
-            "id": 5,
-            "title": "Form Validation and Error States",
-            "description": "Implement visual feedback for form validation and error states",
-            "dependencies": [
-              1,
-              2,
-              4
-            ],
-            "details": "Design and implement inline validation feedback. Create error, warning, and success states for form fields. Add field-level error messages with appropriate styling. Implement form-level error summaries. Ensure error states are visually distinct but maintain accessibility standards.",
-            "status": "done",
-            "testStrategy": ""
-          },
-          {
-            "id": 6,
-            "title": "Accessibility Improvements",
-            "description": "Enhance form accessibility to ensure compliance with WCAG standards",
-            "dependencies": [
-              1,
-              2,
-              3,
-              4,
-              5
-            ],
-            "details": "Add proper ARIA attributes to all form elements. Ensure keyboard navigation works correctly. Implement focus management for error states. Test with screen readers. Add sufficient color contrast for all states. Provide text alternatives for any visual cues. Create documentation for accessibility features.",
-            "status": "done",
-            "testStrategy": ""
-          }
-        ]
-      },
-      {
-        "id": 6,
-        "title": "Enhance List Views",
-        "description": "Improve list views with better row spacing, clearer action buttons, and a more modern aesthetic.",
-        "details": "1. Create CSS overrides for list views in `list_view.css`:\n   - Implement cleaner row styling with appropriate spacing\n   - Style list headers with the new color palette\n   - Improve the display of action buttons and menu items\n   - Enhance filters and search elements\n   - Style pagination controls\n2. If needed, create JavaScript enhancements in `list_view.js` for improved interactions\n3. Ensure consistent styling across different types of lists\n4. Improve the visual display of status indicators and tags\n5. Enhance the responsive behavior for smaller screens\n6. Style bulk action controls and selection checkboxes",
-        "testStrategy": "Test list views across different modules to ensure consistent styling. Verify all list functionality (filtering, sorting, pagination, bulk actions) works correctly with the new styling. Test on different screen sizes to ensure responsive behavior. Check that all action buttons and menus are accessible and visually clear.",
-        "priority": "medium",
-        "dependencies": [
-          2
-        ],
-        "status": "done",
-        "subtasks": [
-          {
-            "id": 1,
-            "title": "Implement List Row and Header Styling",
-            "description": "Redesign and implement the styling for list rows and headers to improve visual hierarchy and readability.",
-            "dependencies": [],
-            "details": "Update the CSS for list rows and headers, including hover states, selected states, and zebra striping. Ensure consistent padding, typography, and alignment across all list views. Update the header styling to clearly distinguish it from the data rows and add appropriate sorting indicators.",
-            "status": "done",
-            "testStrategy": ""
-          },
-          {
-            "id": 2,
-            "title": "Redesign Action Buttons and Menus",
-            "description": "Enhance the visual design and interaction patterns for action buttons and dropdown menus in list views.",
-            "dependencies": [
-              1
-            ],
-            "details": "Redesign action buttons with consistent sizing, iconography, and hover states. Implement improved dropdown menus with proper spacing, dividers for grouped actions, and consistent styling. Ensure tooltip functionality for icon-only buttons and test keyboard accessibility for all interactive elements.",
-            "status": "done",
-            "testStrategy": ""
-          },
-          {
-            "id": 3,
-            "title": "Style Filter and Search Elements",
-            "description": "Update the styling for filter controls, search boxes, and related UI elements to match the new design system.",
-            "dependencies": [
-              1
-            ],
-            "details": "Redesign search input fields with appropriate icons and clear buttons. Implement consistent styling for filter dropdowns, date pickers, and multi-select controls. Ensure visual feedback for active filters and create a cohesive look between search and filter components.",
-            "status": "done",
-            "testStrategy": ""
-          },
-          {
-            "id": 4,
-            "title": "Update Pagination and Bulk Action Controls",
-            "description": "Enhance the design of pagination controls and bulk action interfaces for improved usability.",
-            "dependencies": [
-              1,
-              2
-            ],
-            "details": "Redesign pagination controls with clear current page indicators and appropriate spacing. Implement consistent styling for items-per-page selectors. Update bulk action toolbars to clearly indicate selection state and provide visual feedback when actions are available. Ensure all controls maintain functionality while improving visual design.",
-            "status": "done",
-            "testStrategy": ""
-          },
-          {
-            "id": 5,
-            "title": "Implement Responsive Behavior",
-            "description": "Ensure list views adapt appropriately to different screen sizes with responsive design techniques.",
-            "dependencies": [
-              1,
-              2,
-              3,
-              4
-            ],
-            "details": "Create responsive breakpoints for list views to adapt to mobile, tablet, and desktop screens. Implement column priority hiding for smaller screens, collapsible action menus, and touch-friendly controls for mobile. Test and optimize performance across different device types and screen sizes.",
-            "status": "done",
-            "testStrategy": ""
-          }
-        ]
-      },
-      {
-        "id": 7,
-        "title": "Redesign Dashboard Widgets",
-        "description": "Restyle dashboard widgets for a more modern and visually engaging look that improves data visualization.",
-        "details": "1. Create CSS overrides for dashboard elements in `dashboard.css`:\n   - Implement modern card styling for widgets with subtle shadows and rounded corners\n   - Enhance chart visualizations with the new color palette\n   - Improve spacing and layout of dashboard elements\n   - Style dashboard controls and filters\n2. If needed, create JavaScript enhancements in `dashboard.js` for improved interactions\n3. Ensure consistent styling across different types of widgets (charts, numbers, lists)\n4. Improve the visual hierarchy of information within widgets\n5. Enhance the responsive behavior for dashboard layouts\n6. Consider adding subtle animations or transitions for loading states",
-        "testStrategy": "Test dashboards across different modules to ensure consistent styling. Verify all widget types display correctly with the new styling. Test dashboard customization features to ensure they work with the new design. Check responsive behavior on different screen sizes.",
-        "priority": "medium",
-        "dependencies": [
-          2
-        ],
-        "status": "done",
-        "subtasks": [
-          {
-            "id": 1,
-            "title": "Widget Card Styling and Layout",
-            "description": "Redesign the base widget card container with improved styling, shadows, borders, and header/footer layouts.",
-            "dependencies": [],
-            "details": "Focus on creating a consistent card design system with proper spacing, padding, and border radius. Include header styling with title, subtitle, and action buttons. Design footer area for additional controls or information. Ensure the card has proper elevation/shadow to create visual hierarchy.",
-            "status": "done",
-            "testStrategy": ""
-          },
-          {
-            "id": 2,
-            "title": "Chart and Data Visualization Enhancements",
-            "description": "Improve the visual design and interaction patterns for all chart types (bar, line, pie, etc.) used in dashboard widgets.",
-            "dependencies": [
-              1
-            ],
-            "details": "Update color palettes for better data visualization. Redesign axes, legends, and tooltips for improved readability. Add subtle animations for state changes and interactions. Ensure proper spacing between chart elements and consistent typography for labels.",
-            "status": "done",
-            "testStrategy": ""
-          },
-          {
-            "id": 3,
-            "title": "Dashboard Controls and Filters Redesign",
-            "description": "Redesign the global dashboard controls, filters, and date range selectors for better usability and visual consistency.",
-            "dependencies": [
-              1
-            ],
-            "details": "Create a unified design for filter dropdowns, date pickers, and search inputs. Design collapsible filter panels that don't take excessive space. Implement visual indicators for active filters. Ensure controls have proper states (hover, focus, active) and are accessible.",
-            "status": "done",
-            "testStrategy": ""
-          },
-          {
-            "id": 4,
-            "title": "Widget-Specific Styling Implementation",
-            "description": "Create specialized styling for different widget types including number widgets, list widgets, and specialized chart widgets.",
-            "dependencies": [
-              1,
-              2
-            ],
-            "details": "Design number widgets with appropriate typography hierarchy for metrics vs trends. Create list widget styling with proper item separation and action buttons. Implement specialized styling for KPI indicators (up/down arrows, color coding). Ensure consistent padding and alignment across all widget types.",
-            "status": "done",
-            "testStrategy": ""
-          },
-          {
-            "id": 5,
-            "title": "Responsive Layout Implementation",
-            "description": "Implement responsive behavior for all dashboard widgets to ensure proper display across desktop, tablet, and mobile devices.",
-            "dependencies": [
-              1,
-              2,
-              3,
-              4
-            ],
-            "details": "Define breakpoints for different screen sizes. Create rules for widget resizing, reordering, and stacking on smaller screens. Implement touch-friendly controls for mobile devices. Test and optimize for various screen sizes to ensure data remains readable and accessible.",
-            "status": "done",
-            "testStrategy": ""
-          }
-        ]
-      },
-      {
-        "id": 8,
-        "title": "Implement Global UI Enhancements",
-        "description": "Apply consistent styling improvements across the entire application for elements that appear in multiple contexts.",
-        "details": "1. Create CSS overrides for global elements in `global.css`:\n   - Style modal dialogs and popups\n   - Enhance tooltips and popovers\n   - Improve notification and alert styling\n   - Style common UI components like tabs, accordions, and cards\n   - Implement consistent spacing and alignment rules\n2. If needed, create JavaScript enhancements in `global.js` for improved interactions\n3. Ensure consistent styling for loading indicators and empty states\n4. Improve the styling of error messages and validation feedback\n5. Enhance the visual appearance of data tables and grid components\n6. Style contextual menus and dropdown elements",
-        "testStrategy": "Test various UI components across different parts of the application to ensure consistent styling. Verify all interactive elements work correctly with the new styling. Test error states and loading indicators to ensure they are visually clear. Check accessibility of global UI elements.",
-        "priority": "medium",
-        "dependencies": [
-          2,
-          5,
-          6,
-          7
-        ],
-        "status": "done",
-        "subtasks": [
-          {
-            "id": 1,
-            "title": "Implement Modal and Dialog Styling",
-            "description": "Redesign and implement consistent styling for all modal windows and dialog boxes across the application.",
-            "dependencies": [],
-            "details": "Create a unified design system for modals including: standardized header/footer treatments, consistent close buttons, backdrop styling, animations for opening/closing, responsive behavior for different screen sizes, and accessibility improvements (focus trapping, keyboard navigation).",
-            "status": "done",
-            "testStrategy": ""
-          },
-          {
-            "id": 2,
-            "title": "Develop Tooltip and Popover Redesign",
-            "description": "Redesign tooltips and popovers to improve usability and visual consistency throughout the application.",
-            "dependencies": [],
-            "details": "Update tooltip and popover components with consistent positioning logic, standardized appearance, appropriate animations, arrow indicators, proper z-index management, and ensure they work correctly on all device types. Include documentation for proper implementation.",
-            "status": "done",
-            "testStrategy": ""
-          },
-          {
-            "id": 3,
-            "title": "Enhance Notification and Alert Styling",
-            "description": "Create a comprehensive notification and alert system with consistent styling and behavior patterns.",
-            "dependencies": [],
-            "details": "Develop a unified system for notifications including: toast notifications, inline alerts, status messages, and confirmation dialogs. Implement consistent color coding for different message types (error, warning, success, info), appropriate icons, and animation patterns for appearance/dismissal.",
-            "status": "done",
-            "testStrategy": ""
-          },
-          {
-            "id": 4,
-            "title": "Redesign Tab and Accordion Components",
-            "description": "Update the visual design and interaction patterns for tab navigation and accordion components.",
-            "dependencies": [
-              1,
-              2
-            ],
-            "details": "Implement consistent styling for tabs and accordions including: active/inactive states, hover effects, transition animations, responsive behavior, and accessibility improvements. Ensure proper keyboard navigation and ARIA attributes for screen readers.",
-            "status": "done",
-            "testStrategy": ""
-          },
-          {
-            "id": 5,
-            "title": "Improve Data Tables and Grid Components",
-            "description": "Enhance the visual design and functionality of data tables and grid components.",
-            "dependencies": [
-              2,
-              3
-            ],
-            "details": "Update table and grid components with consistent styling for headers, rows, and cells. Implement standardized sorting indicators, filter controls, pagination elements, row selection, and empty states. Ensure responsive behavior and accessibility compliance.",
-            "status": "done",
-            "testStrategy": ""
-          },
-          {
-            "id": 6,
-            "title": "Design Loading States and Empty State Patterns",
-            "description": "Create consistent loading indicators and empty state designs across the application.",
-            "dependencies": [
-              3,
-              5
-            ],
-            "details": "Develop a unified system for representing loading states (spinners, skeleton screens, progress bars) and empty states (no data, search with no results, etc.). Ensure consistent styling, appropriate animations, and helpful messaging to guide users when content is loading or unavailable.",
-            "status": "done",
-            "testStrategy": ""
-          }
-        ]
-      },
-      {
-        "id": 9,
-        "title": "Implement Responsive Design Optimizations",
-        "description": "Ensure the new theme is fully responsive and works seamlessly across all major browsers and screen sizes.",
-        "details": "1. Create responsive CSS rules in `responsive.css`:\n   - Implement media queries for different screen sizes (desktop, tablet, mobile)\n   - Adjust layout and spacing for smaller screens\n   - Optimize navigation for mobile devices\n   - Ensure form elements are usable on touch devices\n2. Test and fix any responsive issues in the sidebar, header, forms, and list views\n3. Optimize dashboard layouts for different screen sizes\n4. Ensure proper touch targets for mobile users\n5. Test and fix any browser-specific issues (Chrome, Firefox, Safari)\n6. Implement responsive typography that scales appropriately",
-        "testStrategy": "Test the application on various devices (desktop, tablet, smartphone) and browsers (Chrome, Firefox, Safari). Verify all UI elements adjust appropriately to different screen sizes. Check touch interactions on mobile devices. Use browser developer tools to simulate different screen sizes and identify any layout issues.",
-        "priority": "medium",
-        "dependencies": [
-          3,
-          4,
-          5,
-          6,
-          7,
-          8
-        ],
-        "status": "pending",
-        "subtasks": [
-          {
-            "id": 1,
-            "title": "Desktop to Tablet Breakpoint Optimizations",
-            "description": "Implement responsive layout adjustments for screen sizes between desktop and tablet viewports",
-            "dependencies": [],
-            "details": "Analyze current layout issues when transitioning from desktop to tablet sizes (768px-1024px). Adjust grid layouts, navigation components, and sidebar elements to maintain usability. Implement appropriate CSS media queries and test on common tablet resolutions. Document breakpoint decisions for future reference.",
-            "status": "pending",
-            "testStrategy": ""
-          },
-          {
-            "id": 2,
-            "title": "Tablet to Mobile Breakpoint Optimizations",
-            "description": "Optimize UI components and layouts for mobile viewport sizes",
-            "dependencies": [
-              1
-            ],
-            "details": "Implement mobile-specific layouts for screens below 768px. Convert multi-column layouts to single column, implement collapsible navigation, optimize form elements for smaller screens, and ensure touch targets meet accessibility standards. Test on various mobile device sizes and orientations.",
-            "status": "pending",
-            "testStrategy": ""
-          },
-          {
-            "id": 3,
-            "title": "Touch Interface Enhancements",
-            "description": "Improve touch interactions for mobile and tablet users",
-            "dependencies": [
-              1,
-              2
-            ],
-            "details": "Implement touch-friendly UI elements including larger buttons, swipe gestures for common actions, and removal of hover-dependent interactions. Add appropriate touch feedback (visual indicators when elements are touched). Test with actual touch devices to ensure smooth interaction.",
-            "status": "pending",
-            "testStrategy": ""
-          },
-          {
-            "id": 4,
-            "title": "Browser Compatibility Testing and Fixes",
-            "description": "Test responsive design across multiple browsers and fix compatibility issues",
-            "dependencies": [
-              1,
-              2,
-              3
-            ],
-            "details": "Test responsive layouts and interactions in Chrome, Firefox, Safari, and Edge. Document browser-specific issues and implement fixes for inconsistencies. Pay special attention to iOS Safari and older Android browsers. Create a compatibility matrix documenting supported browsers and any known limitations.",
-            "status": "pending",
-            "testStrategy": ""
-          },
-          {
-            "id": 5,
-            "title": "Responsive Typography and Spacing System",
-            "description": "Implement a flexible typography and spacing system that scales across device sizes",
-            "dependencies": [
-              1,
-              2
-            ],
-            "details": "Create a responsive typography system using relative units (rem/em). Implement fluid typography that scales between breakpoints. Develop a consistent spacing system that adjusts proportionally across screen sizes. Document the typography and spacing rules in the design system for future reference.",
-            "status": "pending",
-            "testStrategy": ""
-          }
-        ]
-      },
-      {
-        "id": 10,
-        "title": "Create Documentation and Finalize Package",
-        "description": "Prepare comprehensive documentation and finalize the custom app package for distribution.",
-        "details": "1. Create detailed documentation:\n   - Installation instructions\n   - Configuration options\n   - Customization guidelines\n   - Troubleshooting tips\n2. Add comments to CSS and JavaScript files for maintainability\n3. Optimize assets for production:\n   - Minify CSS and JavaScript files\n   - Optimize images and icons\n4. Create a change log to track versions and updates\n5. Prepare the app for distribution:\n   - Update setup.py with final metadata\n   - Ensure all dependencies are properly listed\n   - Create a release tag in the Git repository\n6. Develop a simple settings page to allow users to customize theme options if desired",
-        "testStrategy": "Verify the documentation is accurate by following the installation instructions on a fresh ERPNext instance. Test the optimized assets to ensure they load correctly and efficiently. Verify the app can be installed from the Git repository using bench commands. Test any configuration options to ensure they work as documented.",
-        "priority": "low",
-        "dependencies": [
-          1,
-          2,
-          3,
-          4,
-          5,
-          6,
-          7,
-          8,
-          9
-        ],
-        "status": "done",
-        "subtasks": [
-          {
-            "id": 1,
-            "title": "Create User and Installation Documentation",
-            "description": "Develop comprehensive documentation for users and installation guides",
-            "dependencies": [],
-            "details": "Create detailed documentation including: installation instructions, theme setup guide, usage examples, configuration options, troubleshooting section, and FAQ. Format documentation in both HTML and markdown for inclusion in the theme package and online distribution. Include screenshots and step-by-step instructions where appropriate.",
-            "status": "done",
-            "testStrategy": ""
-          },
-          {
-            "id": 2,
-            "title": "Optimize Code and Minify Assets",
-            "description": "Perform final code optimization and asset minification for production",
-            "dependencies": [],
-            "details": "Review and optimize all PHP, JavaScript, and CSS code. Minify JS and CSS files. Compress and optimize images and other media assets. Remove any development comments, console logs, and debugging code. Ensure all code follows WordPress coding standards. Run performance tests to verify optimizations.",
-            "status": "done",
-            "testStrategy": ""
-          },
-          {
-            "id": 3,
-            "title": "Implement Theme Configuration Options and Settings Page",
-            "description": "Create a user-friendly settings page for theme configuration",
-            "dependencies": [
-              2
-            ],
-            "details": "Design and implement a settings page in the WordPress admin area. Include options for customizing theme appearance, layout options, social media integration, and other configurable features. Implement form validation and sanitization for all user inputs. Create default configurations that work well out of the box. Test all configuration options thoroughly.",
-            "status": "done",
-            "testStrategy": ""
-          },
-          {
-            "id": 4,
-            "title": "Prepare Release Package and Distribution",
-            "description": "Finalize the theme package and prepare for distribution",
-            "dependencies": [
-              1,
-              2,
-              3
-            ],
-            "details": "Create a final release package including all theme files, documentation, and readme files. Verify theme against WordPress theme requirements and best practices. Test installation process on a clean WordPress installation. Prepare promotional materials and screenshots for theme directory. Create a changelog and version numbering system. Prepare distribution channels (WordPress theme directory, GitHub, etc.).",
-            "status": "done",
-            "testStrategy": ""
-          }
-        ]
-      }
-    ],
-    "metadata": {
-      "created": "2025-06-25T08:10:07.534Z",
-      "updated": "2025-06-25T08:38:54.777Z",
-      "description": "Tasks for master context"
-    }
-  }
-}
\ No newline at end of file
diff --git a/tmp_repo_contents/test-rules b/tmp_repo_contents/test-rules
deleted file mode 100644
index 57f19d7..0000000
--- a/tmp_repo_contents/test-rules
+++ /dev/null
@@ -1,61 +0,0 @@
-**Core Directives & Agentivity:**
-# 1. Adhere strictly to the rules defined below.
-# 2. Use tools sequentially, one per message. Adhere strictly to the rules defined below.
-# 3. CRITICAL: ALWAYS wait for user confirmation of success after EACH tool use before proceeding. Do not assume success.
-# 4. Operate iteratively: Analyze task -> Plan steps -> Execute steps one by one.
-# 5. Use <thinking> tags for *internal* analysis before tool use (context, tool choice, required params).
-# 6. **DO NOT DISPLAY XML TOOL TAGS IN THE OUTPUT.**
-# 7. **DO NOT DISPLAY YOUR THINKING IN THE OUTPUT.**
-
-**Execution Role (Delegated Tasks):**
-
-Your primary role is to **execute** testing tasks delegated to you by the Orchestrator mode. Focus on fulfilling the specific instructions provided in the `new_task` message, referencing the relevant `taskmaster-ai` task ID and its associated context (e.g., `testStrategy`).
-
-1.  **Task Execution:** Perform the requested testing activities as specified in the delegated task instructions. This involves understanding the scope, retrieving necessary context (like `testStrategy` from the referenced `taskmaster-ai` task), planning/preparing tests if needed, executing tests using appropriate tools (`execute_command`, `read_file`, etc.), and analyzing results, strictly adhering to the work outlined in the `new_task` message.
-2.  **Reporting Completion:** Signal completion using `attempt_completion`. Provide a concise yet thorough summary of the outcome in the `result` parameter. This summary is **crucial** for Orchestrator to update `taskmaster-ai`. Include:
-    *   Summary of testing activities performed (e.g., tests planned, executed).
-    *   Concise results/outcome (e.g., pass/fail counts, overall status, coverage information if applicable).
-    *   Completion status (success, failure, needs review - e.g., if tests reveal significant issues needing broader attention).
-    *   Any significant findings (e.g., details of bugs, errors, or validation issues found).
-    *   Confirmation that the delegated testing subtask (mentioning the taskmaster-ai ID if provided) is complete.
-3.  **Handling Issues:**
-    *   **Review Needed:** If tests reveal significant issues requiring architectural review, further debugging, or broader discussion beyond simple bug fixes, set the status to 'review' within your `attempt_completion` result and clearly state the reason (e.g., "Tests failed due to unexpected interaction with Module X, recommend architectural review"). **Do not delegate directly.** Report back to Orchestrator.
-    *   **Failure:** If the testing task itself cannot be completed (e.g., unable to run tests due to environment issues), clearly report the failure and any relevant error information in the `attempt_completion` result.
-4.  **Taskmaster Interaction:**
-    *   **Primary Responsibility:** Orchestrator is primarily responsible for updating Taskmaster (`set_task_status`, `update_task`, `update_subtask`) after receiving your `attempt_completion` result.
-    *   **Direct Updates (Rare):** Only update Taskmaster directly if operating autonomously (not under Orchestrator's delegation) or if *explicitly* instructed by Orchestrator within the `new_task` message.
-5.  **Autonomous Operation (Exceptional):** If operating outside of Orchestrator's delegation (e.g., direct user request), ensure Taskmaster is initialized before attempting Taskmaster operations (see Taskmaster-AI Strategy below).
-
-**Context Reporting Strategy:**
-
-context_reporting: |
-      <thinking>
-      Strategy:
-      - Focus on providing comprehensive information within the `attempt_completion` `result` parameter.
-      - Orchestrator will use this information to update Taskmaster's `description`, `details`, or log via `update_task`/`update_subtask`.
-      - My role is to *report* accurately, not *log* directly to Taskmaster unless explicitly instructed or operating autonomously.
-      </thinking>
-      - **Goal:** Ensure the `result` parameter in `attempt_completion` contains all necessary information for Orchestrator to understand the outcome and update Taskmaster effectively.
-      - **Content:** Include summaries of actions taken (test execution), results achieved (pass/fail, bugs found), errors encountered during testing, decisions made (if any), and any new context discovered relevant to the testing task. Structure the `result` clearly.
-      - **Trigger:** Always provide a detailed `result` upon using `attempt_completion`.
-      - **Mechanism:** Orchestrator receives the `result` and performs the necessary Taskmaster updates.
-
-**Taskmaster-AI Strategy (for Autonomous Operation):**
-
-# Only relevant if operating autonomously (not delegated by Orchestrator).
-taskmaster_strategy:
-  status_prefix: "Begin autonomous responses with either '[TASKMASTER: ON]' or '[TASKMASTER: OFF]'."
-  initialization: |
-      <thinking>
-      - **CHECK FOR TASKMASTER (Autonomous Only):**
-      - Plan: If I need to use Taskmaster tools autonomously, first use `list_files` to check if `tasks/tasks.json` exists.
-      - If `tasks/tasks.json` is present = set TASKMASTER: ON, else TASKMASTER: OFF.
-      </thinking>
-      *Execute the plan described above only if autonomous Taskmaster interaction is required.*
-  if_uninitialized: |
-      1. **Inform:** "Task Master is not initialized. Autonomous Taskmaster operations cannot proceed."
-      2. **Suggest:** "Consider switching to Orchestrator mode to initialize and manage the project workflow."
-  if_ready: |
-      1. **Verify & Load:** Optionally fetch tasks using `taskmaster-ai`'s `get_tasks` tool if needed for autonomous context.
-      2. **Set Status:** Set status to '[TASKMASTER: ON]'.
-      3. **Proceed:** Proceed with autonomous Taskmaster operations.
\ No newline at end of file
diff --git a/tmp_repo_contents/trae_rules.md b/tmp_repo_contents/trae_rules.md
deleted file mode 100644
index 1527ce9..0000000
--- a/tmp_repo_contents/trae_rules.md
+++ /dev/null
@@ -1,53 +0,0 @@
----
-description: Guidelines for creating and maintaining Trae rules to ensure consistency and effectiveness.
-globs: .trae/rules/*.md
-alwaysApply: true
----
-
-- **Required Rule Structure:**
-  ```markdown
-  ---
-  description: Clear, one-line description of what the rule enforces
-  globs: path/to/files/*.ext, other/path/**/*
-  alwaysApply: boolean
-  ---
-
-  - **Main Points in Bold**
-    - Sub-points with details
-    - Examples and explanations
-  ```
-
-- **File References:**
-  - Use `[filename](mdc:path/to/file)` ([filename](mdc:filename)) to reference files
-  - Example: [prisma.md](.trae/rules/prisma.md) for rule references
-  - Example: [schema.prisma](mdc:prisma/schema.prisma) for code references
-
-- **Code Examples:**
-  - Use language-specific code blocks
-  ```typescript
-  // ✅ DO: Show good examples
-  const goodExample = true;
-  
-  // ❌ DON'T: Show anti-patterns
-  const badExample = false;
-  ```
-
-- **Rule Content Guidelines:**
-  - Start with high-level overview
-  - Include specific, actionable requirements
-  - Show examples of correct implementation
-  - Reference existing code when possible
-  - Keep rules DRY by referencing other rules
-
-- **Rule Maintenance:**
-  - Update rules when new patterns emerge
-  - Add examples from actual codebase
-  - Remove outdated patterns
-  - Cross-reference related rules
-
-- **Best Practices:**
-  - Use bullet points for clarity
-  - Keep descriptions concise
-  - Include both DO and DON'T examples
-  - Reference actual code over theoretical examples
-  - Use consistent formatting across rules 
\ No newline at end of file
diff --git a/tmp_repo_contents/vscode_rules.md b/tmp_repo_contents/vscode_rules.md
deleted file mode 100644
index c566d24..0000000
--- a/tmp_repo_contents/vscode_rules.md
+++ /dev/null
@@ -1,53 +0,0 @@
----
-description: Guidelines for creating and maintaining VS Code rules to ensure consistency and effectiveness.
-applyTo: ".github/instructions/*.md"
-alwaysApply: true
----
-
-- **Required Rule Structure:**
-  ```markdown
-  ---
-  description: Clear, one-line description of what the rule enforces
-  globs: path/to/files/*.ext, other/path/**/*
-  alwaysApply: boolean
-  ---
-
-  - **Main Points in Bold**
-    - Sub-points with details
-    - Examples and explanations
-  ```
-
-- **File References:**
-  - Use `[filename](mdc:path/to/file)` ([filename](mdc:filename)) to reference files
-  - Example: [prisma.md](.github/instructions/prisma.md) for rule references
-  - Example: [schema.prisma](mdc:prisma/schema.prisma) for code references
-
-- **Code Examples:**
-  - Use language-specific code blocks
-  ```typescript
-  // ✅ DO: Show good examples
-  const goodExample = true;
-  
-  // ❌ DON'T: Show anti-patterns
-  const badExample = false;
-  ```
-
-- **Rule Content Guidelines:**
-  - Start with high-level overview
-  - Include specific, actionable requirements
-  - Show examples of correct implementation
-  - Reference existing code when possible
-  - Keep rules DRY by referencing other rules
-
-- **Rule Maintenance:**
-  - Update rules when new patterns emerge
-  - Add examples from actual codebase
-  - Remove outdated patterns
-  - Cross-reference related rules
-
-- **Best Practices:**
-  - Use bullet points for clarity
-  - Keep descriptions concise
-  - Include both DO and DON'T examples
-  - Reference actual code over theoretical examples
-  - Use consistent formatting across rules 
\ No newline at end of file
diff --git a/tmp_repo_contents/windsurf_rules.md b/tmp_repo_contents/windsurf_rules.md
deleted file mode 100644
index b85515f..0000000
--- a/tmp_repo_contents/windsurf_rules.md
+++ /dev/null
@@ -1,53 +0,0 @@
----
-description: Guidelines for creating and maintaining Windsurf rules to ensure consistency and effectiveness.
-globs: .windsurf/rules/*.md
-alwaysApply: true
----
-
-- **Required Rule Structure:**
-  ```markdown
-  ---
-  description: Clear, one-line description of what the rule enforces
-  globs: path/to/files/*.ext, other/path/**/*
-  alwaysApply: boolean
-  ---
-
-  - **Main Points in Bold**
-    - Sub-points with details
-    - Examples and explanations
-  ```
-
-- **File References:**
-  - Use `[filename](mdc:path/to/file)` ([filename](mdc:filename)) to reference files
-  - Example: [prisma.md](.windsurf/rules/prisma.md) for rule references
-  - Example: [schema.prisma](mdc:prisma/schema.prisma) for code references
-
-- **Code Examples:**
-  - Use language-specific code blocks
-  ```typescript
-  // ✅ DO: Show good examples
-  const goodExample = true;
-  
-  // ❌ DON'T: Show anti-patterns
-  const badExample = false;
-  ```
-
-- **Rule Content Guidelines:**
-  - Start with high-level overview
-  - Include specific, actionable requirements
-  - Show examples of correct implementation
-  - Reference existing code when possible
-  - Keep rules DRY by referencing other rules
-
-- **Rule Maintenance:**
-  - Update rules when new patterns emerge
-  - Add examples from actual codebase
-  - Remove outdated patterns
-  - Cross-reference related rules
-
-- **Best Practices:**
-  - Use bullet points for clarity
-  - Keep descriptions concise
-  - Include both DO and DON'T examples
-  - Reference actual code over theoretical examples
-  - Use consistent formatting across rules 
\ No newline at end of file
